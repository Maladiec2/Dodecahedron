<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî∑ 3D Dodecahedron - Unified Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        /* Header */
        .page-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 15px 30px;
            backdrop-filter: blur(20px);
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid rgba(0, 255, 204, 0.3);
        }

        .page-header.hidden {
            display: none;
        }

        .page-title {
            font-size: 20px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #00ffcc;
        }

        .page-subtitle {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 3px;
            letter-spacing: 1px;
        }

        /* Mode Selector */
        .mode-selector {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(10px);
        }

        .mode-selector-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mode-button {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-family: inherit;
            letter-spacing: 0.5px;
        }

        .mode-button:hover {
            background: rgba(0, 255, 204, 0.1);
            border-color: rgba(0, 255, 204, 0.5);
            color: #00ffcc;
        }

        .mode-button.active {
            background: rgba(0, 255, 204, 0.2);
            border-color: #00ffcc;
            color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }

        .mode-button-label {
            display: block;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .mode-button-desc {
            font-size: 9px;
            opacity: 0.7;
        }

        /* Canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        /* Control Panel (Standard mode) */
        .controls-panel {
            position: fixed;
            top: 90px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 200;
            max-height: calc(100vh - 110px);
            overflow-y: auto;
        }

        .controls-panel h3 {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 2px;
            color: #00ffcc;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            font-size: 10px;
            opacity: 0.7;
            margin-bottom: 8px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button {
            width: 100%;
            padding: 10px;
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 6px;
            color: #00ffcc;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            margin-bottom: 8px;
        }

        .control-button:hover {
            background: rgba(0, 255, 204, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .control-button.active {
            background: rgba(0, 255, 204, 0.3);
            border-color: #00ffcc;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        .stats-label {
            opacity: 0.7;
        }

        .stats-value {
            color: #00ffcc;
            font-weight: 600;
        }

        /* Analysis Panel (Advanced/Complete modes) */
        .analysis-panel {
            position: fixed;
            top: 90px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 110px);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 200;
            overflow-y: auto;
            display: none;
        }

        .analysis-panel.visible {
            display: block;
        }

        .analysis-section {
            padding: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .analysis-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            color: #00ffcc;
            margin-bottom: 12px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
        }

        .metric-label {
            opacity: 0.7;
        }

        .metric-value {
            color: #00ffcc;
            font-weight: 600;
        }

        .metric-value.critical {
            color: #ff6b6b;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.success {
            color: #00ff66;
        }

        /* Face Detail Panel */
        .face-detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 500px;
            max-width: 90vw;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(0, 255, 204, 0.5);
            border-radius: 16px;
            padding: 30px;
            backdrop-filter: blur(20px);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0, 255, 204, 0.3);
        }

        .face-detail-panel.visible {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scale(1);
        }

        .face-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .face-detail-title {
            font-size: 20px;
            font-weight: 600;
            color: #00ffcc;
            letter-spacing: 1px;
        }

        .face-detail-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .face-detail-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .face-energy-display {
            font-size: 48px;
            font-weight: 300;
            text-align: center;
            margin: 20px 0;
            color: #00ffcc;
        }

        .face-energy-label {
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .kpi-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
        }

        .kpi-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .kpi-name {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
        }

        .kpi-element {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .kpi-element.earth {
            background: rgba(120, 120, 120, 0.3);
            color: #999;
        }

        .kpi-element.water {
            background: rgba(30, 144, 255, 0.3);
            color: #4a9eff;
        }

        .kpi-element.fire {
            background: rgba(255, 120, 0, 0.3);
            color: #ff9944;
        }

        .kpi-element.air {
            background: rgba(0, 200, 150, 0.3);
            color: #00d9a3;
        }

        .kpi-element.ether {
            background: rgba(100, 100, 200, 0.3);
            color: #8888dd;
        }

        .kpi-value-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .kpi-value-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .kpi-value-fill.healthy {
            background: linear-gradient(90deg, #00ff88, #00ffcc);
        }

        .kpi-value-fill.warning {
            background: linear-gradient(90deg, #ffa500, #ffcc00);
        }

        .kpi-value-fill.critical {
            background: linear-gradient(90deg, #ff4444, #ff6b6b);
        }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 200;
        }

        .legend-title {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 9999;
        }

        .loading.hidden {
            display: none;
        }

        .loading-text {
            font-size: 14px;
            color: #00ffcc;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 204, 0.2);
            border-top-color: #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Tooltip */
        .face-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(0, 255, 204, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            z-index: 1500;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 4px 20px rgba(0, 255, 204, 0.3);
        }

        .face-tooltip.visible {
            opacity: 1;
        }

        .tooltip-face-name {
            font-size: 13px;
            font-weight: 600;
            color: #00ffcc;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }

        .tooltip-energy {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }

        .tooltip-energy-value {
            font-weight: 600;
            margin-left: 4px;
        }

        .tooltip-hint {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 6px;
            font-style: italic;
        }

        /* Edge Tooltip */
        .edge-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 204, 0, 0.6);
            border-radius: 8px;
            padding: 10px 14px;
            backdrop-filter: blur(10px);
            z-index: 1600;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 4px 20px rgba(255, 204, 0, 0.3);
            min-width: 200px;
            color: #fff;
        }

        .edge-tooltip.visible {
            opacity: 1;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 204, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 204, 0.5);
        }

        /* Phase Warning Overlay */
        .phase-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 170, 0, 0.15);
            border: 2px solid #ffaa00;
            border-radius: 12px;
            padding: 20px 30px;
            backdrop-filter: blur(10px);
            z-index: 500;
            animation: pulse 2s ease-in-out infinite;
            display: none;
        }

        .phase-warning.visible {
            display: block;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        .phase-warning-title {
            font-size: 18px;
            font-weight: 600;
            color: #ffaa00;
            margin-bottom: 10px;
            text-align: center;
        }

        .phase-warning-message {
            font-size: 14px;
            text-align: center;
            line-height: 1.6;
        }

        /* Insight Cards */
        .insight-card {
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 11px;
        }

        .insight-card.warning {
            background: rgba(255, 170, 0, 0.1);
            border-left-color: #ffaa00;
        }

        .insight-card.opportunity {
            background: rgba(0, 255, 102, 0.1);
            border-left-color: #00ff66;
        }

        .insight-card.critical {
            background: rgba(255, 107, 107, 0.15);
            border-left-color: #ff6b6b;
        }

        .insight-title {
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .insight-message {
            opacity: 0.9;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .insight-action {
            opacity: 0.8;
            font-size: 10px;
            font-style: italic;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Shadow Alerts */
        .shadow-alert {
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 12px;
        }

        .shadow-alert-title {
            font-weight: 600;
            color: #ff6b6b;
            margin-bottom: 4px;
        }

        /* Leverage Points */
        .leverage-point {
            background: rgba(255, 255, 0, 0.1);
            border-left: 3px solid #ffff00;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 12px;
        }

        .leverage-point-title {
            font-weight: 600;
            color: #ffff00;
            margin-bottom: 4px;
        }

        /* Harmonic Tuner Dashboard */
        .harmonic-tuner {
            position: fixed;
            bottom: -200px;
            /* Hidden by default */
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            height: 180px;
            background: linear-gradient(180deg, rgba(10, 15, 20, 0.95) 0%, rgba(0, 0, 0, 1) 100%);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-bottom: none;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -10px 50px rgba(0, 255, 204, 0.1);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 0 40px;
            transition: bottom 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
            backdrop-filter: blur(20px);
        }

        .harmonic-tuner.visible {
            bottom: 0;
        }

        .tuner-toggle {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-bottom: none;
            padding: 5px 20px;
            border-radius: 10px 10px 0 0;
            color: #00ffcc;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% {
                box-shadow: 0 -2px 5px rgba(0, 255, 204, 0.1);
            }

            50% {
                box-shadow: 0 -5px 15px rgba(0, 255, 204, 0.4);
            }

            100% {
                box-shadow: 0 -2px 5px rgba(0, 255, 204, 0.1);
            }
        }

        .tuner-toggle:hover {
            background: rgba(0, 255, 204, 0.2);
            animation: none;
            box-shadow: 0 -5px 20px rgba(0, 255, 204, 0.3);
        }

        /* Tooltip System */
        .tuner-tooltip {
            position: absolute;
            background: rgba(10, 15, 20, 0.95);
            border: 1px solid #00ffcc;
            border-radius: 8px;
            padding: 12px;
            width: 220px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
        }

        .tuner-tooltip.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-20px);
        }

        .tooltip-title {
            color: #00ffcc;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tooltip-desc {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            line-height: 1.4;
        }

        .info-icon {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            background: rgba(0, 255, 204, 0.2);
            border: 1px solid rgba(0, 255, 204, 0.5);
            border-radius: 50%;
            color: #00ffcc;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: help;
            opacity: 0.7;
            transition: all 0.2s;
        }

        .info-icon:hover {
            opacity: 1;
            background: rgba(0, 255, 204, 0.4);
            transform: scale(1.1);
        }

        /* Knob Container */
        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            width: 80px;
        }

        .knob-label {
            color: #00ffcc;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
        }

        .knob-sublabel {
            color: rgba(255, 255, 255, 0.5);
            font-size: 8px;
            margin-top: 2px;
        }

        /* The Rotary Knob */
        .knob-control {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #2a2a2a, #000);
            border: 2px solid rgba(0, 255, 204, 0.2);
            position: relative;
            cursor: ns-resize;
            /* Up/down drag cursor */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.05);
            transition: border-color 0.3s;
        }

        .knob-control:hover {
            border-color: rgba(0, 255, 204, 0.6);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
        }

        .knob-control::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background: #00ffcc;
            border-radius: 50%;
            box-shadow: 0 0 5px #00ffcc;
        }

        /* Indicator Ring (SVG) */
        .knob-ring {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 70px;
            height: 70px;
            pointer-events: none;
            transform: rotate(-90deg);
            /* Start from top */
        }

        .knob-ring circle {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
        }

        .knob-ring-bg {
            stroke: rgba(255, 255, 255, 0.1);
        }

        .knob-ring-value {
            stroke: #00ffcc;
            stroke-dasharray: 176;
            /* 2 * PI * r (r=28) approx */
            stroke-dashoffset: 176;
            transition: stroke-dashoffset 0.1s;
        }


        /* Resonance Meter */
        .resonance-meter {
            width: 160px;
            height: 100px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 10px;
            margin: 0 20px;
            overflow: hidden;
        }

        .meter-scale {
            width: 140px;
            height: 70px;
            border-top-left-radius: 70px;
            border-top-right-radius: 70px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-bottom: none;
            position: relative;
            box-sizing: border-box;
        }

        .meter-needle {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 2px;
            height: 60px;
            background: #ff3333;
            transform-origin: bottom center;
            transform: rotate(-45deg);
            transition: transform 0.5s cubic-bezier(0.2, 1.5, 0.5, 1);
            /* Bouncy needle */
            box-shadow: 0 0 5px #ff3333;
            z-index: 2;
        }

        .meter-needle.tuned {
            background: #00ffcc;
            box-shadow: 0 0 10px #00ffcc;
        }

        .meter-label {
            margin-top: 10px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
        }

        .meter-value {
            font-size: 16px;
            font-weight: 700;
            color: #fff;
            margin-top: 5px;
        }
    </style>
    <link rel="stylesheet" href="css/harmonic-tuner.css">
</head>

<body>
    <!-- Header -->
    <div class="page-header" id="pageHeader">
        <div class="page-title">üî∑ 3D Dodecahedron</div>
        <div class="page-subtitle" id="pageSubtitle">Interactive Organizational Geometry</div>
    </div>

    <!-- Mode Selector -->
    <div class="mode-selector">
        <div class="mode-selector-title">Visualization Mode</div>
        <div class="mode-buttons">
            <button class="mode-button active" id="modeStandard" onclick="switchMode('standard')">
                <span class="mode-button-label">Standard</span>
                <span class="mode-button-desc">Company data & controls</span>
            </button>
            <button class="mode-button" id="modeAdvanced" onclick="switchMode('advanced')">
                <span class="mode-button-label">Advanced</span>
                <span class="mode-button-desc">Edge tensions & vortices</span>
            </button>
            <button class="mode-button" id="modeComplete" onclick="switchMode('complete')">
                <span class="mode-button-label">Complete</span>
                <span class="mode-button-desc">Full dynamics analysis</span>
            </button>
            <button class="mode-button" id="modeMinimal" onclick="switchMode('minimal')">
                <span class="mode-button-label">Minimal</span>
                <span class="mode-button-desc">Clean presentation</span>
            </button>
        </div>
    </div>

    <!-- Phase Warning Overlay -->
    <div id="phase-warning" class="phase-warning">
        <div class="phase-warning-title">‚ö†Ô∏è PHASE TRANSITION IMMINENT</div>
        <div class="phase-warning-message" id="phase-warning-message"></div>
    </div>

    <!-- Loading -->
    <div class="loading" id="loading">
        <div class="loading-text">INITIALIZING GEOMETRY</div>
        <div class="loading-spinner"></div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container">
        <canvas id="scene"></canvas>
    </div>

    <!-- Controls Panel (Standard Mode) -->
    <div class="controls-panel" id="controlsPanel">
        <h3>Controls</h3>

        <div class="control-group">
            <label class="control-label">Controls</label>
            <button class="control-button" id="toggleRotation">Auto-Rotate: OFF</button>
        </div>



        <div class="control-group">
            <label class="control-label">Company</label>
            <button class="control-button" id="companyQuannex">Quannex</button>
            <button class="control-button" id="companyNova">Nova Tech</button>
            <button class="control-button" id="companyZenith">Zenith Solutions</button>
            <button class="control-button" id="companyApex">Apex Industries</button>
        </div>

        <div class="control-group">
            <label class="control-label">Global Stats</label>
            <div class="stats-item">
                <span class="stats-label">Coherence</span>
                <span class="stats-value" id="statCoherence">--</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Status</span>
                <span class="stats-value" id="statStatus">--</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Faces</span>
                <span class="stats-value">12</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Edges</span>
                <span class="stats-value">30</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Instructions</label>
            <div style="font-size: 11px; opacity: 0.7; line-height: 1.6;">
                ‚Ä¢ <strong>Hover</strong> over faces for info<br>
                ‚Ä¢ <strong>Click</strong> faces for details<br>
                ‚Ä¢ <strong>Drag</strong> to rotate manually<br>
                ‚Ä¢ <strong>Scroll</strong> to zoom in/out<br>
                ‚Ä¢ <strong>R</strong> - Reset camera view<br>
                ‚Ä¢ <strong>Space</strong> - Toggle rotation<br>
                ‚Ä¢ <strong>ESC</strong> - Close panels
            </div>
        </div>
    </div>

    <!-- Analysis Panel (Advanced/Complete Modes) -->
    <div class="analysis-panel" id="analysisPanel">
        <div id="analysisContent">
            <!-- Will be populated by JavaScript -->
        </div>
    </div>

    <!-- Legend -->
    <div class="legend" id="legend">
        <div class="legend-title">Face Energy</div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #00ff88, #00ffcc);"></div>
            <span>Healthy (70-100%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #ffa500, #ffcc00);"></div>
            <span>Warning (40-70%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #ff4444, #ff6b6b);"></div>
            <span>Critical (0-40%)</span>
        </div>
    </div>

    <!-- Face Detail Panel -->
    <div class="face-detail-panel" id="faceDetailPanel">
        <div class="face-detail-header">
            <div class="face-detail-title" id="faceDetailTitle">Face Name</div>
            <button class="face-detail-close" id="closeFaceDetail">&times;</button>
        </div>

        <div class="face-energy-display" id="faceEnergyDisplay">--</div>
        <div class="face-energy-label">FACE ENERGY</div>

        <div class="kpi-grid" id="kpiGrid">
            <!-- KPIs will be injected here -->
        </div>

        <!-- Connected Edges Section -->
        <div class="analysis-section" id="connectedEdgesSection" style="display: none;">
            <div class="section-title">üîó Connected Edges</div>
            <div id="connectedEdgesList">
                <!-- Edges will be injected here -->
            </div>
        </div>

        <!-- Corner Vertices Section -->
        <div class="analysis-section" id="cornerVerticesSection" style="display: none;">
            <div class="section-title">üåÄ Corner Vortices</div>
            <div id="cornerVerticesList">
                <!-- Vertices will be injected here -->
            </div>
        </div>
    </div>

    <!-- Hover Tooltip (Faces) -->
    <div class="face-tooltip" id="faceTooltip">
        <div class="tooltip-face-name" id="tooltipFaceName">Face Name</div>
        <div class="tooltip-energy">
            Energy: <span class="tooltip-energy-value" id="tooltipEnergyValue">--</span>
        </div>
        <div class="tooltip-hint">Click to view details</div>
    </div>

    <!-- Edge Tooltip -->
    <div class="edge-tooltip" id="edgeTooltip">
        <!-- Content will be dynamically injected -->
    </div>

    <!-- Vertex Tooltip -->
    <div class="edge-tooltip" id="vertexTooltip"
        style="border-color: rgba(255, 0, 100, 0.6); box-shadow: 0 4px 20px rgba(255, 0, 100, 0.3);">
        <!-- Content will be dynamically injected -->
    </div>

    <!-- Three.js Library -->
    <script src="https://unpkg.com/three@0.128.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Load breath analyzer first -->
    <script src="js/breath-analyzer.js"></script>

    <!-- Load spectral analyzer (required for engine) -->
    <script src="js/spectral-analyzer.js"></script>

    <!-- Main Quannex Engine (modules) -->
    <script type="module" src="js/main.js"></script>
    <script type="module" src="js/company-loader.js"></script>

    <!-- Visualization Manager -->
    <script type="module" src="js/advanced/visualization-manager.js"></script>

    <!-- Dodecahedron Visualization -->
    <script src="js/dodecahedron-viz.js"></script>

    <script type="module">
        // Import advanced analyzers (lazy loaded when needed)
        let SpectralAnalyzer, EdgeAnalyzer, VertexAnalyzer, ShadowDetector, DynamicsAnalyzer, AIEdgeInterpreter;
        let analyzersLoaded = false;

        async function loadAdvancedAnalyzers() {
            if (analyzersLoaded) return;

            try {
                const modules = await Promise.all([
                    import('./js/advanced/spectral-analyzer.js'),
                    import('./js/advanced/edge-analyzer.js'),
                    import('./js/advanced/vertex-analyzer.js?v=2'),
                    import('./js/advanced/shadow-detector.js'),
                    import('./js/advanced/ai-edge-interpreter.js'),
                ]);

                // Assign to window for global access (needed by VisualizationManager)
                window.SpectralAnalyzer = modules[0].SpectralAnalyzer;
                window.EdgeAnalyzer = modules[1].EdgeAnalyzer;
                window.VertexAnalyzer = modules[2].VertexAnalyzer;
                window.ShadowDetector = modules[3].ShadowDetector;
                window.AIEdgeInterpreter = modules[4].AIEdgeInterpreter;

                // Update local references for compatibility
                SpectralAnalyzer = window.SpectralAnalyzer;
                EdgeAnalyzer = window.EdgeAnalyzer;
                VertexAnalyzer = window.VertexAnalyzer;
                ShadowDetector = window.ShadowDetector;
                AIEdgeInterpreter = window.AIEdgeInterpreter;

                analyzersLoaded = true;
                console.log('‚úÖ Advanced analyzers loaded (including AI Edge Interpreter)');
            } catch (error) {
                console.error('‚ùå Failed to load analyzers:', error);
            }
        }

        async function loadDynamicsAnalyzer() {
            if (DynamicsAnalyzer) return;

            try {
                const module = await import('./js/advanced/dynamics-analyzer.js');
                window.DynamicsAnalyzer = module.DynamicsAnalyzer;
                DynamicsAnalyzer = window.DynamicsAnalyzer;
                console.log('‚úÖ Dynamics analyzer loaded');
            } catch (error) {
                console.error('‚ùå Failed to load dynamics analyzer:', error);
            }
        }

        // Global state
        let currentMode = 'standard';
        let currentLoadedCompanyId = null;
        let edgeLines = [];
        let vertexSpheres = [];
        let feedbackLoopLines = [];
        let advancedAnalysisResults = null;

        // Mode switching
        window.switchMode = async function (mode) {
            console.log(`üîÑ Switching to ${mode} mode`);
            currentMode = mode;

            // Update UI
            updateModeUI(mode);

            // Load required analyzers
            if (mode === 'advanced' || mode === 'complete') {
                await loadAdvancedAnalyzers();
            }
            if (mode === 'complete') {
                await loadDynamicsAnalyzer();
            }

            // Update visualization with mode-specific features
            await updateVisualizationForMode(mode);
        };

        // Advanced visualization update
        async function updateVisualizationForMode(mode) {
            const scene = window.scene;
            if (!scene) {
                console.warn('‚ö†Ô∏è Scene not ready yet');
                return;
            }

            // Clear existing advanced visualizations
            clearAdvancedVisualizations();

            if (mode === 'standard' || mode === 'minimal') {
                // Base visualization only
                advancedAnalysisResults = null;
                window.advancedAnalysisResults = null;
                console.log('‚úÖ Standard/Minimal mode - base visualization active');
                return;
            }

            // Get company data
            const companyData = window.Quannex ? window.Quannex.getState() : null;
            if (!companyData || !companyData.faces) {
                console.warn('‚ö†Ô∏è No company data available');
                return;
            }

            // Run analyses
            const faceEnergies = companyData.faces.map(f => f.faceEnergy);

            if (mode === 'advanced') {
                await runAdvancedAnalysis(companyData, faceEnergies);
                renderEdgeTensions();
                renderVertexVortices();
                updateAnalysisPanel();
            } else if (mode === 'complete') {
                await runCompleteAnalysis(companyData, faceEnergies);
                renderEdgeTensions();
                renderVertexVortices();
                renderFeedbackLoops();
                updateAnalysisPanel();
                checkPhaseTransitionWarning();

                // Highlight frozen faces (System Inertia)
                if (advancedAnalysisResults.dynamics && window.dodecahedronMaterials) {
                    const materials = window.dodecahedronMaterials;
                    companyData.faces.forEach((face, i) => {
                        if (i < materials.length) {
                            const frozenFace = advancedAnalysisResults.dynamics.inertia.faceInertia.find(f => f.faceId === face.id);
                            if (frozenFace && frozenFace.responsiveness === 'Frozen') {
                                materials[i].emissiveIntensity = 0.8; // High glow for frozen faces
                                materials[i].needsUpdate = true;
                            }
                        }
                    });
                }
            }
        }

        // Initialize Visualization Manager (Lazy Load)
        let vizManager = null;

        function initVizManager() {
            if (vizManager) return vizManager;

            if (window.scene && window.camera && window.renderer) {
                vizManager = new VisualizationManager(window.scene, window.camera, window.renderer.domElement);
                console.log('‚úÖ VisualizationManager initialized');
                return vizManager;
            }
            return null;
        }

        // Run advanced analysis (Delegated to VisualizationManager)
        async function runAdvancedAnalysis(companyData, faceEnergies) {
            if (!analyzersLoaded) {
                console.warn('‚ö†Ô∏è Analyzers not loaded yet');
                return;
            }

            // Ensure VizManager is initialized
            if (!vizManager) {
                if (!initVizManager()) {
                    console.warn('‚ö†Ô∏è Scene not ready for VisualizationManager');
                    return;
                }
            }

            // Delegate to VisualizationManager
            const results = await vizManager.runAdvancedAnalysis(companyData, faceEnergies);

            // Update local reference for compatibility
            advancedAnalysisResults = results;
            window.advancedAnalysisResults = results;
        }

        // Run complete analysis (advanced + dynamics)
        async function runCompleteAnalysis(companyData, faceEnergies) {
            await runAdvancedAnalysis(companyData, faceEnergies);

            if (!DynamicsAnalyzer) {
                console.warn('‚ö†Ô∏è Dynamics analyzer not loaded');
                return;
            }

            const dynamics = new DynamicsAnalyzer();
            const dynamicsAnalysis = dynamics.analyzeComplete(
                companyData.faces,
                advancedAnalysisResults.edges,
                advancedAnalysisResults.spectral
            );

            advancedAnalysisResults.dynamics = dynamicsAnalysis;

            // Update window reference
            window.advancedAnalysisResults = advancedAnalysisResults;

            // Update VisualizationManager state if needed (it stores results internally too)
            if (vizManager || initVizManager()) {
                vizManager.advancedAnalysisResults.dynamics = dynamicsAnalysis;
            }

            console.log('‚úÖ Complete dynamics analysis done');
        }

        // Render edge tensions (Delegated)
        function renderEdgeTensions() {
            if (vizManager || initVizManager()) {
                vizManager.renderEdgeTensions();
            }
        }

        // Render vertex vortices (Delegated)
        function renderVertexVortices() {
            if (vizManager || initVizManager()) {
                vizManager.renderVertexVortices();
            }
        }

        // Render feedback loops (Delegated)
        function renderFeedbackLoops() {
            if (vizManager || initVizManager()) {
                vizManager.renderFeedbackLoops();
            }
        }

        // Clear visualizations (Delegated)
        function clearAdvancedVisualizations() {
            if (vizManager || initVizManager()) {
                vizManager.clear();
            }
        }

        // Expose functions to window for external access (dodecahedron-viz.js)
        window.runAdvancedAnalysis = runAdvancedAnalysis;
        window.renderEdgeTensions = renderEdgeTensions;
        window.renderVertexVortices = renderVertexVortices;
        window.renderFeedbackLoops = renderFeedbackLoops;
        window.clearAdvancedVisualizations = clearAdvancedVisualizations;

        // Cache for extracted vertices and topology mapping
        let cachedGeometricVertices = null;
        let cachedVertexToFacesMap = null;
        let cachedAnalyticalToGeometricMap = null;



        // Authoritative vertex-to-face mapping extracted from Three.js geometry
        // This maps analytical vertex ID (1-20) to the 3 face IDs it connects
        // NOTE: This will be populated at runtime from the actual geometry
        let AUTHORITATIVE_VERTEX_TOPOLOGY = null;

        /**
         * Build a topology-aware mapping from Three.js face indices to analytical Face IDs
         * Returns an array where index = Three.js face index (0-11), value = analytical Face ID (1-12)
         */




        /**
         * Extract the ACTUAL vertex topology from the rendered Three.js geometry
         * This is the ground truth - what the dodecahedron actually looks like
         */
        function extractActualTopologyFromGeometry() {
            const vertexToFacesMap = buildVertexToFacesMap();

            if (!vertexToFacesMap || vertexToFacesMap.size === 0) {
                console.error('‚ùå Could not extract topology from geometry - no face meshes available');
                return null;
            }

            console.log('\nüîç EXTRACTED ACTUAL TOPOLOGY FROM THREE.JS GEOMETRY:');
            console.log('='.repeat(60));

            const topology = {};
            vertexToFacesMap.forEach((faceSet, geoIdx) => {
                const faces = Array.from(faceSet).sort((a, b) => a - b);
                topology[geoIdx] = faces;
                console.log(`Vertex ${geoIdx + 1}: faces [${faces.join(', ')}] (${faces.length} faces)`);
            });

            console.log('='.repeat(60));
            console.log(`‚úÖ Extracted ${Object.keys(topology).length} vertices from actual geometry\n`);

            // Validate topology
            const vertexCount = Object.keys(topology).length;
            const invalidVertices = Object.entries(topology).filter(([, faces]) => faces.length !== 3);

            if (vertexCount !== 20) {
                console.error(`‚ùå ERROR: Expected 20 vertices, got ${vertexCount}`);
            }

            if (invalidVertices.length > 0) {
                console.error(`‚ùå ERROR: ${invalidVertices.length} vertices don't have exactly 3 faces:`);
                invalidVertices.forEach(([idx, faces]) => {
                    console.error(`   Vertex ${parseInt(idx) + 1}: ${faces.length} faces - [${faces.join(', ')}]`);
                });
            }

            if (vertexCount === 20 && invalidVertices.length === 0) {
                console.log('‚úÖ VALIDATION PASSED: All 20 vertices have exactly 3 faces');
            }

            return topology;
        }

        /**
         * Build the authoritative vertex-to-face topology
         * Uses ACTUAL geometry as ground truth, then maps to analytical vertex IDs
         */
        function buildAuthoritativeTopology() {
            // Extract actual topology from rendered geometry
            const geometricTopology = extractActualTopologyFromGeometry();

            if (!geometricTopology) {
                console.warn('‚ö†Ô∏è Geometry extraction failed, using CSV fallback topology');
                // Return CSV topology as fallback
                return {
                    1: [1, 2, 6],     // V1: Foundation Nexus
                    2: [1, 5, 6],     // V2: Resource Core
                    3: [1, 8, 9],     // V3: Action Point
                    4: [2, 9, 10],    // V4: Growth Catalyst
                    5: [2, 3, 10],    // V5: Development Hub
                    6: [2, 3, 6],     // V6: Social Nexus
                    7: [3, 10, 11],   // V7: Learning Junction
                    8: [4, 5, 6],     // V8: Brand Anchor
                    9: [1, 5, 8],     // V9: Strategic Vortex
                    10: [4, 5, 7],    // V10: Excellence Hub
                    11: [3, 4, 11],   // V11: Governance Core
                    12: [4, 7, 11],   // V12: Leadership Point
                    13: [5, 7, 8],    // V13: Vision Bridge
                    14: [7, 8, 12],   // V14: Future Nexus
                    15: [7, 11, 12],  // V15: Wisdom Center
                    16: [8, 9, 12],   // V16: Impact Junction
                    17: [9, 10, 12],  // V17: Evolution Point
                    18: [10, 11, 12], // V18: Sustainability Anchor
                    19: [3, 4, 6],    // V19: Culture Nexus
                    20: [1, 2, 9]     // V20: Wisdom Center
                };
            }

            // For now, use geometric indices as analytical IDs (geoIdx + 1 = analyticalId)
            // This will show us the ACTUAL topology, then we can map archetypes to it
            const topology = {};
            Object.entries(geometricTopology).forEach(([geoIdx, faces]) => {
                const analyticalId = parseInt(geoIdx) + 1; // Convert to 1-indexed
                topology[analyticalId] = faces;
            });

            console.log('üìä Using EXTRACTED topology as authoritative source');
            return topology;
        }

        /**
         * Get the authoritative vertex topology, building it if not yet initialized
         */
        function getAuthoritativeTopology() {
            if (!AUTHORITATIVE_VERTEX_TOPOLOGY) {
                AUTHORITATIVE_VERTEX_TOPOLOGY = buildAuthoritativeTopology();
            }
            return AUTHORITATIVE_VERTEX_TOPOLOGY;
        }

        /**
         * Find the 2 vertices that form the shared edge between two faces
         * @param {number} face1 - First face ID (1-12)
         * @param {number} face2 - Second face ID (1-12)
         * @returns {Array<number>} Array of 2 vertex IDs, or null if faces don't share an edge
         */
        function findSharedEdgeVertices(face1Id, face2Id) {
            // Get the authoritative topology (builds from geometry if not yet initialized)
            const topology = getAuthoritativeTopology();
            const sharedVertexIds = [];

            // Check each vertex (1-20) to see if it connects to both faces
            for (let vertexId = 1; vertexId <= 20; vertexId++) {
                const connectedFaces = topology[vertexId];

                if (!connectedFaces) continue;

                // If this vertex connects to both faces, it's part of the shared edge
                if (connectedFaces.includes(face1Id) && connectedFaces.includes(face2Id)) {
                    sharedVertexIds.push(vertexId);
                }
            }

            // Two adjacent faces should share exactly 2 vertices
            if (sharedVertexIds.length !== 2) {
                console.warn(`‚ö†Ô∏è Faces ${face1Id} and ${face2Id} share ${sharedVertexIds.length} vertices (expected 2)`);
                return null;
            }

            // Convert vertex IDs to geometric positions
            const geometricVertices = getDodecahedronVertices();
            const sharedPositions = sharedVertexIds.map(vertexId => {
                const geoIndex = getGeometricVertexIndex(vertexId);
                return geometricVertices[geoIndex];
            });

            // Verify we got valid positions
            if (!sharedPositions[0] || !sharedPositions[1]) {
                console.warn(`‚ö†Ô∏è Could not map vertex IDs ${sharedVertexIds} to positions for edge ${face1Id}-${face2Id}`);
                return null;
            }

            return sharedPositions; // Returns array of 2 THREE.Vector3 positions
        }

        // Build a map of geometric vertex index -> face indices
        window.buildVertexToFacesMap = function () {
            if (cachedVertexToFacesMap) {
                return cachedVertexToFacesMap;
            }

            const faceMeshes = window.dodecahedronViz?.faceMeshes;
            const geometricVertices = getDodecahedronVertices();

            if (!faceMeshes || faceMeshes.length === 0) {
                console.warn('‚ö†Ô∏è No face meshes available for topology mapping');
                return null;
            }

            // Map: geometricVertexIndex -> Set of faceIndices (1-12, 1-indexed to match authoritative data)
            const vertexToFaces = new Map();

            // For each geometric vertex, find which faces it belongs to
            geometricVertices.forEach((geoVertex, geoIdx) => {
                const connectedFaces = new Set();

                // Check each face mesh
                faceMeshes.forEach((mesh, faceIdx) => {
                    const positions = mesh.geometry.attributes.position;

                    // Check if this face contains this vertex
                    for (let i = 0; i < positions.count; i++) {
                        const vx = positions.getX(i);
                        const vy = positions.getY(i);
                        const vz = positions.getZ(i);

                        // Check if this face vertex matches the geometric vertex
                        const distance = Math.sqrt(
                            Math.pow(vx - geoVertex.x, 2) +
                            Math.pow(vy - geoVertex.y, 2) +
                            Math.pow(vz - geoVertex.z, 2)
                        );

                        if (distance < 0.01) { // Tolerance for floating point comparison
                            connectedFaces.add(faceIdx + 1); // +1 because analytical faces are 1-indexed
                            break;
                        }
                    }
                });

                if (connectedFaces.size > 0) {
                    vertexToFaces.set(geoIdx, connectedFaces);
                }
            });

            console.log(`‚úÖ Built vertex-to-faces topology map for ${vertexToFaces.size} vertices`);

            cachedVertexToFacesMap = vertexToFaces;
            return vertexToFaces;
        }

        // Find the geometric vertex index by matching face connectivity
        function getGeometricVertexIndex(vertexId) {
            // Check if we already have a cached mapping
            if (!cachedAnalyticalToGeometricMap) {
                cachedAnalyticalToGeometricMap = new Map();
            }

            if (cachedAnalyticalToGeometricMap.has(vertexId)) {
                return cachedAnalyticalToGeometricMap.get(vertexId);
            }

            // Use authoritative topology data extracted from geometry
            const topology = getAuthoritativeTopology();
            const authoritativeFaces = topology[vertexId];

            if (!authoritativeFaces) {
                console.warn(`‚ö†Ô∏è No authoritative topology data for vertex ${vertexId}`);
                return 0;
            }

            // Build vertex-to-faces topology map if not already built
            const vertexToFaces = buildVertexToFacesMap();

            if (!vertexToFaces) {
                console.warn('‚ö†Ô∏è Topology mapping failed, using fallback');
                // Fallback to proximity-based method
                if (advancedAnalysisResults && advancedAnalysisResults.vertices) {
                    const vertex = advancedAnalysisResults.vertices.find(v => v.id === vertexId);
                    if (vertex) {
                        return getGeometricVertexIndexByProximity(vertex);
                    }
                }
                return 0;
            }

            // Convert authoritative face IDs to a Set for comparison
            const authoritativeFaceSet = new Set(authoritativeFaces);

            // Find the geometric vertex whose face connectivity matches the authoritative data
            let bestMatch = null;
            let bestMatchScore = 0;

            vertexToFaces.forEach((geoFaces, geoIdx) => {
                // Skip if already mapped to another analytical vertex
                const alreadyMapped = Array.from(cachedAnalyticalToGeometricMap.values()).includes(geoIdx);
                if (alreadyMapped) return;

                // Calculate match score (how many faces match)
                let matchCount = 0;
                authoritativeFaceSet.forEach(faceId => {
                    if (geoFaces.has(faceId)) {
                        matchCount++;
                    }
                });

                // Perfect match requires all 3 faces to match
                if (matchCount === 3 && geoFaces.size === 3) {
                    bestMatch = geoIdx;
                    bestMatchScore = 3;
                } else if (matchCount > bestMatchScore) {
                    // Partial match - take the best one
                    bestMatch = geoIdx;
                    bestMatchScore = matchCount;
                }
            });

            const finalIndex = bestMatch !== null ? bestMatch : 0;
            cachedAnalyticalToGeometricMap.set(vertexId, finalIndex);

            console.log(`üìç Vertex ${vertexId}: authoritative faces ${JSON.stringify(authoritativeFaces)} ‚Üí geometric index ${finalIndex} (match score: ${bestMatchScore})`);

            return finalIndex;
        }

        // Fallback: Find geometric vertex by proximity (old method)
        function getGeometricVertexIndexByProximity(vertex) {
            // Get the centers of the 3 faces that meet at this vertex
            const faceCenters = vertex.faceIds.map(faceId => getFaceCenterPosition(faceId - 1)).filter(p => p !== null);
            if (faceCenters.length !== 3) return 0;

            // Calculate the average position (approximate vertex location)
            const avgPos = new THREE.Vector3();
            faceCenters.forEach(center => avgPos.add(center));
            avgPos.divideScalar(faceCenters.length);

            // Find the closest actual vertex from the Three.js geometry
            const geometricVertices = getDodecahedronVertices();
            let closestIndex = 0;
            let minDistance = Infinity;

            geometricVertices.forEach((geoVertex, index) => {
                const distance = avgPos.distanceTo(geoVertex);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });

            return closestIndex;
        }

        // Get vertex position using actual geometric vertices
        function getVertexPosition(vertexFaceIds) {
            // Find which vertex this is by matching face IDs
            if (!advancedAnalysisResults || !advancedAnalysisResults.vertices) return null;

            const vertex = advancedAnalysisResults.vertices.find(v =>
                v.faceIds.length === vertexFaceIds.length &&
                v.faceIds.every(id => vertexFaceIds.includes(id))
            );

            if (!vertex) return null;

            // Map to geometric vertex and get position
            const geometricIndex = getGeometricVertexIndex(vertex.id); // Fixed: use vertex.id
            const geometricVertices = getDodecahedronVertices();

            return geometricVertices[geometricIndex];
        }

        // Update analysis panel with current results
        function updateAnalysisPanel() {
            if (!advancedAnalysisResults) return;

            const content = document.getElementById('analysisContent');
            const { spectral, edges, vertices, shadows, dynamics } = advancedAnalysisResults;

            let html = `
                <!-- Spectral Analysis -->
                <div class="analysis-section">
                    <div class="section-title">üéµ Spectral Mode</div>
                    <div class="metric-row">
                        <span class="metric-label">Pattern</span>
                        <span class="metric-value">${spectral.summary.pattern}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Eigenvalue Œª</span>
                        <span class="metric-value">${spectral.dominantMode.eigenvalue.toFixed(3)}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Dissonance</span>
                        <span class="metric-value ${spectral.diagnostics.dissonanceIndex.percentage > 20 ? 'critical' : 'success'}">
                            ${spectral.diagnostics.dissonanceIndex.percentage.toFixed(1)}%
                        </span>
                    </div>
                </div>

                <!-- Edge Tensions -->
                <div class="analysis-section">
                    <div class="section-title">üîó Edge Tensions</div>
                    <div class="metric-row">
                        <span class="metric-label">Total Edges</span>
                        <span class="metric-value">${edges.length}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">High Tension</span>
                        <span class="metric-value">${edges.filter(e => e.tension > 0.4).length} edges</span>
                    </div>
                </div>

                <!-- Vortex Dynamics -->
                <div class="analysis-section">
                    <div class="section-title">üåÄ Vortex Dynamics</div>
                    <div class="metric-row">
                        <span class="metric-label">Total Vertices</span>
                        <span class="metric-value">${vertices.length}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Strong Vortices</span>
                        <span class="metric-value">${vertices.filter(v => v.vortexStrength > 0.5).length}</span>
                    </div>
                    
                    <!-- Leverage Points List -->
                    ${(() => {
                    // Calculate leverage points if not available in summary
                    const leveragePoints = vertices.filter(v => v.isLeveragePoint)
                        .sort((a, b) => b.vortexStrength - a.vortexStrength)
                        .slice(0, 3);

                    if (leveragePoints.length > 0) {
                        return `
                                <div style="margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                                    <div style="font-size: 11px; opacity: 0.7; margin-bottom: 6px;">TOP LEVERAGE POINTS</div>
                                    ${leveragePoints.map(v => `
                                        <div class="leverage-point">
                                            <div class="leverage-point-title">V${v.id}: ${v.archetype || 'Unknown'}</div>
                                            <div style="font-size: 11px; opacity: 0.8;">Strength: ${(v.vortexStrength * 100).toFixed(0)}%</div>
                                        </div>
                                    `).join('')}
                                </div>
                             `;
                    }
                    return '';
                })()}
                </div>

                <!-- Shadow Detection -->
                <div class="analysis-section">
                    <div class="section-title">üëÅÔ∏è Shadow Patterns</div>
                    <div class="metric-row">
                        <span class="metric-label">Detected</span>
                        <span class="metric-value ${shadows.totalPatternsDetected > 0 ? 'critical' : 'success'}">
                            ${shadows.totalPatternsDetected} patterns
                        </span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Integrity</span>
                        <span class="metric-value ${shadows.systemIntegrity.score < 0.7 ? 'critical' : 'success'}">
                            ${(shadows.systemIntegrity.score * 100).toFixed(1)}%
                        </span>
                    </div>

                    ${shadows.detectedPatterns.length > 0 ? `
                        <div style="margin-top: 12px;">
                            ${shadows.detectedPatterns.map(pattern => `
                                <div class="shadow-alert">
                                    <div class="shadow-alert-title">${pattern.icon || '‚ö†Ô∏è'} ${pattern.pattern}</div>
                                    <div style="font-size: 11px; opacity: 0.8;">${pattern.severity ? pattern.severity.toUpperCase() : 'DETECTED'}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : '<div style="font-size: 12px; opacity: 0.7; margin-top: 10px;">No shadows detected ‚úÖ</div>'}
                </div>
            `;

            // Add dynamics section for Complete mode
            if (dynamics) {
                html += `
                    <!-- System Dynamics -->
                    <div class="analysis-section">
                        <div class="section-title">‚ö° System Dynamics</div>
                        <div class="metric-row">
                            <span class="metric-label">Pattern</span>
                            <span class="metric-value">${dynamics.feedbackLoops.summary.dominantPattern}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Trajectory</span>
                            <span class="metric-value">${dynamics.attractors.trajectory.type}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Stability</span>
                            <span class="metric-value">${dynamics.attractors.stability.status}</span>
                        </div>
                    </div>

                    <!-- Feedback Loops -->
                    <div class="analysis-section">
                        <div class="section-title">üîÑ Feedback Loops</div>
                        <div class="metric-row">
                            <span class="metric-label">Total Loops</span>
                            <span class="metric-value">${dynamics.feedbackLoops.summary.totalLoops}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Vicious</span>
                            <span class="metric-value critical">${dynamics.feedbackLoops.summary.vicious}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Virtuous</span>
                            <span class="metric-value success">${dynamics.feedbackLoops.summary.virtuous}</span>
                        </div>
                    </div>

                    <!-- Phase Transitions -->
                    <div class="analysis-section">
                        <div class="section-title">üåä Phase Transitions</div>
                        <div class="metric-row">
                            <span class="metric-label">Nearest</span>
                            <span class="metric-value">${dynamics.phaseTransitions.nearestTransition.name}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Proximity</span>
                            <span class="metric-value ${dynamics.phaseTransitions.proximity > 0.7 ? 'warning' : ''}">
                                ${(dynamics.phaseTransitions.proximity * 100).toFixed(0)}%
                            </span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Likelihood</span>
                            <span class="metric-value">${dynamics.phaseTransitions.prediction.likelihood}</span>
                        </div>
                    </div>

                    <!-- System Inertia -->
                    <div class="analysis-section">
                        <div class="section-title">‚è≥ System Inertia</div>
                        <div class="metric-row">
                            <span class="metric-label">Frozen Faces</span>
                            <span class="metric-value ${dynamics.inertia.summary.frozenFaces > 3 ? 'critical' : ''}">
                                ${dynamics.inertia.summary.frozenFaces}
                            </span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Flexibility</span>
                            <span class="metric-value">${dynamics.inertia.summary.systemFlexibility.status}</span>
                        </div>
                    </div>

                    <!-- Critical Insights -->
                    ${dynamics.summary.criticalInsights.length > 0 ? `
                        <div class="analysis-section">
                            <div class="section-title">‚ö° Critical Insights</div>
                            ${dynamics.summary.criticalInsights.map(insight => `
                                <div class="insight-card ${insight.type.toLowerCase()}">
                                    <div class="insight-title">${insight.type}: ${insight.category}</div>
                                    <div class="insight-message">${insight.message}</div>
                                    <div class="insight-action">‚Üí ${insight.action}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }

            content.innerHTML = html;
        }

        function updateModeUI(mode) {
            // Update mode buttons
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');

            // Update subtitle
            const subtitles = {
                standard: 'Interactive Organizational Geometry',
                advanced: 'Advanced Mathematical Visualization with Edge Tensions & Vortex Dynamics',
                complete: 'Complete Mathematical Oracle - Full Dynamics & Feedback Analysis',
                minimal: 'Clean Presentation View'
            };
            document.getElementById('pageSubtitle').textContent = subtitles[mode];

            // Show/hide panels
            const controlsPanel = document.getElementById('controlsPanel');
            const analysisPanel = document.getElementById('analysisPanel');
            const legend = document.getElementById('legend');
            const modeSelector = document.querySelector('.mode-selector');

            if (mode === 'standard') {
                controlsPanel.style.display = 'block';
                analysisPanel.classList.remove('visible');
                legend.style.display = 'block';
                modeSelector.style.display = 'block';
            } else if (mode === 'advanced' || mode === 'complete') {
                controlsPanel.style.display = 'none';
                analysisPanel.classList.add('visible');
                legend.style.display = 'block';
                modeSelector.style.display = 'block';
            } else if (mode === 'minimal') {
                controlsPanel.style.display = 'none';
                analysisPanel.classList.remove('visible');
                legend.style.display = 'none';
                modeSelector.style.display = 'none';
            }
        }

        // Parent-child communication (from standard mode)
        window.addEventListener('message', async (event) => {
            const { type, companyId } = event.data;

            if (type === 'LOAD_COMPANY') {
                console.log(`[3D View] üì® Received company load request from parent: ${companyId}`);

                if (currentLoadedCompanyId === companyId) {
                    console.log(`[3D View] ‚ÑπÔ∏è Company "${companyId}" is already loaded, skipping duplicate load`);
                    return;
                }

                try {
                    const loading = document.getElementById('loading');
                    if (loading) loading.classList.remove('hidden');

                    if (companyId && window.CompanyLoader) {
                        console.log(`[3D View] üîÑ Loading company: ${companyId}`);
                        const company = await window.CompanyLoader.loadCompany(companyId);

                        if (window.Quannex) {
                            await window.Quannex.initWithCompany(company);
                        }

                        if (window.refreshVisualization) {
                            window.refreshVisualization();
                        }

                        currentLoadedCompanyId = companyId;

                        const state = window.Quannex ? window.Quannex.getState() : null;
                        if (state) {
                            const coherencePercent = (state.globalCoherence * 100).toFixed(1);
                            document.getElementById('statCoherence').textContent = coherencePercent + '%';

                            const status = state.globalCoherence >= 0.7 ? 'Healthy' :
                                state.globalCoherence >= 0.5 ? 'Moderate' : 'Critical';
                            document.getElementById('statStatus').textContent = status;
                        }

                        if (loading) loading.classList.add('hidden');

                        console.log(`[3D View] ‚úÖ Loaded company from parent: ${company.name}`);
                    } else {
                        console.warn('[3D View] ‚ö†Ô∏è CompanyLoader not available');
                    }
                } catch (error) {
                    console.error('[3D View] ‚ùå Failed to load company from parent:', error);
                    const loading = document.getElementById('loading');
                    if (loading) loading.classList.add('hidden');
                }
            }
        });

        // Check sessionStorage for custom data
        async function checkSessionStorage() {
            const selectedCompanyId = sessionStorage.getItem('selectedCompanyId');
            const customDataJson = sessionStorage.getItem('customCompanyData');

            if (selectedCompanyId === 'custom' && customDataJson) {
                try {
                    console.log(`[3D View] üé® Loading CUSTOM data from orchestrator`);
                    const customData = JSON.parse(customDataJson);

                    const loading = document.getElementById('loading');
                    if (loading) loading.classList.remove('hidden');

                    const company = {
                        id: 'custom',
                        name: customData.name || 'Custom Analysis',
                        description: customData.description || 'User-generated data',
                        kpis: customData.kpis || [],
                        faceConfig: customData.faceConfig || null
                    };

                    let attempts = 0;
                    while (!window.Quannex && attempts < 10) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                        attempts++;
                    }

                    if (window.Quannex) {
                        await window.Quannex.initWithCompany(company);

                        if (window.refreshVisualization) {
                            window.refreshVisualization();
                        }

                        const state = window.Quannex.getState();
                        if (state) {
                            const coherencePercent = (state.globalCoherence * 100).toFixed(1);
                            document.getElementById('statCoherence').textContent = coherencePercent + '%';

                            const status = state.globalCoherence >= 0.7 ? 'Healthy' :
                                state.globalCoherence >= 0.5 ? 'Moderate' : 'Critical';
                            document.getElementById('statStatus').textContent = status;
                        }

                        const companyButtons = document.querySelectorAll('.control-group button[id^="company"]');
                        if (companyButtons.length > 0) {
                            companyButtons.forEach(btn => btn.style.display = 'none');
                        }
                        const companyLabel = document.querySelector('.control-group .control-label');
                        if (companyLabel && companyLabel.textContent === 'Company') {
                            companyLabel.textContent = 'Custom Analysis';
                        }
                    }

                    currentLoadedCompanyId = 'custom';

                    if (loading) loading.classList.add('hidden');

                    console.log(`[3D View] ‚úÖ Successfully loaded custom data`);
                    return true;
                } catch (error) {
                    console.error('[3D View] ‚ùå Failed to load custom data:', error);
                }
            } else if (window.self !== window.top && selectedCompanyId) {
                if (selectedCompanyId && !currentLoadedCompanyId) {
                    console.log(`[3D View] üíæ Found company ID in sessionStorage: ${selectedCompanyId}`);
                    window.postMessage({ type: 'LOAD_COMPANY', companyId: selectedCompanyId }, '*');
                }
            }
        }

        // Auto-refresh polling
        let lastKnownTimestamp = null;

        function checkForUpdates() {
            const customDataJson = sessionStorage.getItem('customCompanyData');
            if (!customDataJson) return;

            try {
                const customData = JSON.parse(customDataJson);
                const newTimestamp = customData.timestamp;

                if (lastKnownTimestamp && newTimestamp !== lastKnownTimestamp) {
                    console.log('[3D View] üîÑ Detected data update! Reloading...');
                    checkSessionStorage();
                }

                lastKnownTimestamp = newTimestamp;
            } catch (error) {
                console.error('[3D View] ‚ùå Error checking for updates:', error);
            }
        }

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('[3D View] üëÄ Tab became visible - checking for updates...');
                checkForUpdates();
            }
        });

        setInterval(checkForUpdates, 2000);

        // Check if in iframe
        if (window.self !== window.top) {
            document.getElementById('pageHeader').classList.add('hidden');
        }

        // Initialize
        setTimeout(checkSessionStorage, 1000);



        function checkPhaseTransitionWarning() {
            if (!advancedAnalysisResults || !advancedAnalysisResults.dynamics) return;

            const transitions = advancedAnalysisResults.dynamics.phaseTransitions;

            if (transitions.isImminent) {
                const warning = document.getElementById('phase-warning');
                const message = document.getElementById('phase-warning-message');

                message.textContent = `${transitions.nearestTransition.name} transition detected! ` +
                    `${transitions.prediction.message}`;

                warning.classList.add('visible');

                // Hide after 10 seconds
                setTimeout(() => {
                    warning.classList.remove('visible');
                }, 10000);
            }
        }

        console.log('[3D View] üì° Unified visualization initialized');
        console.log('[3D View] üé® Mode system ready - Standard/Advanced/Complete/Minimal');

    </script>
    <!-- Harmonic Tuner Dashboard -->
    <div class="harmonic-tuner" id="harmonicTuner">
        <div class="tuner-toggle" id="tunerToggle">‚ñ≤ Harmonic Tuner</div>
        <div class="god-mode-btn" id="godModeBtn" title="Non-Duality Mode (Delta 0.5)">‚àû</div>

        <!-- Alpha: Synergy -->
        <div class="knob-group">
            <div class="knob-label">Alpha<div class="knob-sublabel">Synergy</div>
            </div>
            <div class="info-icon" data-title="Alpha (Synergy)"
                data-desc="Controls the blend between individual brilliance (Arithmetic) and collective synergy (Geometric). Low = Soloist, High = Orchestra.">
                ?</div>
            <div class="knob-control" id="knobAlpha" data-param="ALPHA" data-min="0" data-max="1" data-step="0.1"
                data-value="0.6">
                <svg class="knob-ring" viewBox="0 0 90 90">
                    <circle class="knob-ring-bg" cx="45" cy="45" r="35"></circle>
                    <circle class="knob-ring-value" cx="45" cy="45" r="35"></circle>
                </svg>
            </div>
            <div class="knob-value-display" id="dispAlpha">0.6</div>
        </div>

        <!-- Beta: Structure -->
        <div class="knob-group">
            <div class="knob-label">Beta<div class="knob-sublabel">Structure</div>
            </div>
            <div class="info-icon" data-title="Beta (Structure)"
                data-desc="Adjusts the rigidity of the organizational lattice. Low = Fluid/Organic, High = Crystalline/Stable.">
                ?</div>
            <div class="knob-control" id="knobBeta" data-param="BETA" data-min="0" data-max="1" data-step="0.1"
                data-value="0.5">
                <svg class="knob-ring" viewBox="0 0 90 90">
                    <circle class="knob-ring-bg" cx="45" cy="45" r="35"></circle>
                    <circle class="knob-ring-value" cx="45" cy="45" r="35"></circle>
                </svg>
            </div>
            <div class="knob-value-display" id="dispBeta">0.5</div>
        </div>

        <!-- Resonance Meter -->
        <div class="resonance-meter">
            <div class="info-icon" style="top: 5px; right: 5px;" data-title="Resonance Meter"
                data-desc="Visualizes the real-time coherence of the organization. Aim for the green zone (>80%) for optimal harmonic alignment.">
                ?</div>
            <div class="meter-scale">
                <div class="meter-needle" id="meterNeedle"></div>
            </div>
            <div class="meter-value" id="meterValue">0%</div>
            <div class="meter-label">Resonance</div>
        </div>

        <!-- Gamma: Balance -->
        <div class="knob-group">
            <div class="knob-label">Gamma<div class="knob-sublabel">Balance</div>
            </div>
            <div class="info-icon" data-title="Gamma (Balance)"
                data-desc="Balances Internal Gravity (Culture) vs External Reach (Market). Low = Hunter, High = Builder.">
                ?</div>
            <div class="knob-control" id="knobGamma" data-param="GAMMA" data-min="0" data-max="1" data-step="0.1"
                data-value="0.7">
                <svg class="knob-ring" viewBox="0 0 90 90">
                    <circle class="knob-ring-bg" cx="45" cy="45" r="35"></circle>
                    <circle class="knob-ring-value" cx="45" cy="45" r="35"></circle>
                </svg>
            </div>
            <div class="knob-value-display" id="dispGamma">0.7</div>
        </div>

        <!-- Delta: Shadow -->
        <div class="knob-group">
            <div class="knob-label">Delta<div class="knob-sublabel">Shadow</div>
            </div>
            <div class="info-icon" data-title="Delta (Shadow)"
                data-desc="Controls sensitivity to hidden risks and friction. Low = Optimist, High = Analyst (Crisis Scan).">
                ?</div>
            <div class="knob-control" id="knobDelta" data-param="DELTA" data-min="0" data-max="1" data-step="0.1"
                data-value="0.9">
                <svg class="knob-ring" viewBox="0 0 90 90">
                    <circle class="knob-ring-bg" cx="45" cy="45" r="35"></circle>
                    <circle class="knob-ring-value" cx="45" cy="45" r="35"></circle>
                </svg>
            </div>
            <div class="knob-value-display" id="dispDelta">0.9</div>
        </div>

        <!-- Kappa: Gain -->
        <div class="knob-group">
            <div class="knob-label">Kappa<div class="knob-sublabel">Gain</div>
            </div>
            <div class="info-icon" data-title="Kappa (Gain)"
                data-desc="Amplifies weak signals to make them visible. Low = Noise Gate, High = Deep Scan.">?</div>
            <div class="knob-control" id="knobKappa" data-param="KAPPA" data-min="1" data-max="10" data-step="0.5"
                data-value="2.0">
                <svg class="knob-ring" viewBox="0 0 90 90">
                    <circle class="knob-ring-bg" cx="45" cy="45" r="35"></circle>
                    <circle class="knob-ring-value" cx="45" cy="45" r="35"></circle>
                </svg>
            </div>
            <div class="knob-value-display" id="dispKappa">2.0</div>
        </div>

        <!-- Tooltip Element -->
        <div class="tuner-tooltip" id="tunerTooltip">
            <div class="tooltip-title"></div>
            <div class="tooltip-desc"></div>
        </div>
    </div>

    <!-- Load Harmonic Tuner Logic -->
    <script src="js/harmonic-tuner.js"></script>

</body>

</html>
```