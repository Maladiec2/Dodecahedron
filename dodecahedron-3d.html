<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ”· 3D Dodecahedron - Unified Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        /* Header */
        .page-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 15px 30px;
            backdrop-filter: blur(20px);
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid rgba(0, 255, 204, 0.3);
        }

        .page-header.hidden {
            display: none;
        }

        .page-title {
            font-size: 20px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #00ffcc;
        }

        .page-subtitle {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 3px;
            letter-spacing: 1px;
        }

        /* Mode Selector */
        .mode-selector {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(10px);
        }

        .mode-selector-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mode-button {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-family: inherit;
            letter-spacing: 0.5px;
        }

        .mode-button:hover {
            background: rgba(0, 255, 204, 0.1);
            border-color: rgba(0, 255, 204, 0.5);
            color: #00ffcc;
        }

        .mode-button.active {
            background: rgba(0, 255, 204, 0.2);
            border-color: #00ffcc;
            color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }

        .mode-button-label {
            display: block;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .mode-button-desc {
            font-size: 9px;
            opacity: 0.7;
        }

        /* Canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        /* Control Panel (Standard mode) */
        .controls-panel {
            position: fixed;
            top: 90px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 200;
            max-height: calc(100vh - 110px);
            overflow-y: auto;
        }

        .controls-panel h3 {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 2px;
            color: #00ffcc;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            font-size: 10px;
            opacity: 0.7;
            margin-bottom: 8px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button {
            width: 100%;
            padding: 10px;
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 6px;
            color: #00ffcc;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            margin-bottom: 8px;
        }

        .control-button:hover {
            background: rgba(0, 255, 204, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .control-button.active {
            background: rgba(0, 255, 204, 0.3);
            border-color: #00ffcc;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        .stats-label {
            opacity: 0.7;
        }

        .stats-value {
            color: #00ffcc;
            font-weight: 600;
        }

        /* Analysis Panel (Advanced/Complete modes) */
        .analysis-panel {
            position: fixed;
            top: 90px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 110px);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 200;
            overflow-y: auto;
            display: none;
        }

        .analysis-panel.visible {
            display: block;
        }

        .analysis-section {
            padding: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .analysis-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            color: #00ffcc;
            margin-bottom: 12px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
        }

        .metric-label {
            opacity: 0.7;
        }

        .metric-value {
            color: #00ffcc;
            font-weight: 600;
        }

        .metric-value.critical {
            color: #ff6b6b;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.success {
            color: #00ff66;
        }

        /* Face Detail Panel */
        .face-detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 500px;
            max-width: 90vw;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(0, 255, 204, 0.5);
            border-radius: 16px;
            padding: 30px;
            backdrop-filter: blur(20px);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0, 255, 204, 0.3);
        }

        .face-detail-panel.visible {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scale(1);
        }

        .face-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .face-detail-title {
            font-size: 20px;
            font-weight: 600;
            color: #00ffcc;
            letter-spacing: 1px;
        }

        .face-detail-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .face-detail-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .face-energy-display {
            font-size: 48px;
            font-weight: 300;
            text-align: center;
            margin: 20px 0;
            color: #00ffcc;
        }

        .face-energy-label {
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .kpi-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
        }

        .kpi-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .kpi-name {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
        }

        .kpi-element {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .kpi-element.earth { background: rgba(120, 120, 120, 0.3); color: #999; }
        .kpi-element.water { background: rgba(30, 144, 255, 0.3); color: #4a9eff; }
        .kpi-element.fire { background: rgba(255, 120, 0, 0.3); color: #ff9944; }
        .kpi-element.air { background: rgba(0, 200, 150, 0.3); color: #00d9a3; }
        .kpi-element.ether { background: rgba(100, 100, 200, 0.3); color: #8888dd; }

        .kpi-value-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .kpi-value-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .kpi-value-fill.healthy { background: linear-gradient(90deg, #00ff88, #00ffcc); }
        .kpi-value-fill.warning { background: linear-gradient(90deg, #ffa500, #ffcc00); }
        .kpi-value-fill.critical { background: linear-gradient(90deg, #ff4444, #ff6b6b); }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 200;
        }

        .legend-title {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 9999;
        }

        .loading.hidden {
            display: none;
        }

        .loading-text {
            font-size: 14px;
            color: #00ffcc;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 204, 0.2);
            border-top-color: #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltip */
        .face-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(0, 255, 204, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            z-index: 1500;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 4px 20px rgba(0, 255, 204, 0.3);
        }

        .face-tooltip.visible {
            opacity: 1;
        }

        .tooltip-face-name {
            font-size: 13px;
            font-weight: 600;
            color: #00ffcc;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }

        .tooltip-energy {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }

        .tooltip-energy-value {
            font-weight: 600;
            margin-left: 4px;
        }

        .tooltip-hint {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 6px;
            font-style: italic;
        }

        /* Edge Tooltip */
        .edge-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 204, 0, 0.6);
            border-radius: 8px;
            padding: 10px 14px;
            backdrop-filter: blur(10px);
            z-index: 1600;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 4px 20px rgba(255, 204, 0, 0.3);
            min-width: 200px;
            color: #fff;
        }

        .edge-tooltip.visible {
            opacity: 1;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 204, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 204, 0.5);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="page-header" id="pageHeader">
        <div class="page-title">ðŸ”· 3D Dodecahedron</div>
        <div class="page-subtitle" id="pageSubtitle">Interactive Organizational Geometry</div>
    </div>

    <!-- Mode Selector -->
    <div class="mode-selector">
        <div class="mode-selector-title">Visualization Mode</div>
        <div class="mode-buttons">
            <button class="mode-button active" id="modeStandard" onclick="switchMode('standard')">
                <span class="mode-button-label">Standard</span>
                <span class="mode-button-desc">Company data & controls</span>
            </button>
            <button class="mode-button" id="modeAdvanced" onclick="switchMode('advanced')">
                <span class="mode-button-label">Advanced</span>
                <span class="mode-button-desc">Edge tensions & vortices</span>
            </button>
            <button class="mode-button" id="modeComplete" onclick="switchMode('complete')">
                <span class="mode-button-label">Complete</span>
                <span class="mode-button-desc">Full dynamics analysis</span>
            </button>
            <button class="mode-button" id="modeMinimal" onclick="switchMode('minimal')">
                <span class="mode-button-label">Minimal</span>
                <span class="mode-button-desc">Clean presentation</span>
            </button>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading" id="loading">
        <div class="loading-text">INITIALIZING GEOMETRY</div>
        <div class="loading-spinner"></div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container">
        <canvas id="scene"></canvas>
    </div>

    <!-- Controls Panel (Standard Mode) -->
    <div class="controls-panel" id="controlsPanel">
        <h3>Controls</h3>

        <div class="control-group">
            <label class="control-label">Controls</label>
            <button class="control-button" id="toggleRotation">Auto-Rotate: OFF</button>
        </div>

        <div class="control-group">
            <label class="control-label">Tuning (Conductor's Settings)</label>
            
            <div class="stats-item">
                <span class="stats-label" title="Synergy Blend (Arithmetic vs Geometric)">Î± Alpha (Synergy)</span>
                <span class="stats-value" id="valAlpha">0.6</span>
            </div>
            <input type="range" id="rangeAlpha" min="0" max="1" step="0.1" value="0.6" style="width: 100%; margin-bottom: 8px;">

            <div class="stats-item">
                <span class="stats-label" title="Intersection Blend (Symmetry)">Î² Beta (Symmetry)</span>
                <span class="stats-value" id="valBeta">0.5</span>
            </div>
            <input type="range" id="rangeBeta" min="0" max="1" step="0.1" value="0.5" style="width: 100%; margin-bottom: 8px;">

            <div class="stats-item">
                <span class="stats-label" title="Ball vs Pillar Blend (Internal vs Relational)">Î³ Gamma (Balance)</span>
                <span class="stats-value" id="valGamma">0.7</span>
            </div>
            <input type="range" id="rangeGamma" min="0" max="1" step="0.1" value="0.7" style="width: 100%; margin-bottom: 8px;">

            <div class="stats-item">
                <span class="stats-label" title="Axis Coherence Factor (Shadow Influence)">Î´ Delta (Shadow)</span>
                <span class="stats-value" id="valDelta">0.9</span>
            </div>
            <input type="range" id="rangeDelta" min="0" max="1" step="0.1" value="0.9" style="width: 100%; margin-bottom: 8px;">

            <div class="stats-item">
                <span class="stats-label" title="Sensitivity Amplifier">Îº Kappa (Gain)</span>
                <span class="stats-value" id="valKappa">2.0</span>
            </div>
            <input type="range" id="rangeKappa" min="1" max="10" step="0.5" value="2.0" style="width: 100%; margin-bottom: 8px;">
        </div>

        <div class="control-group">
            <label class="control-label">Company</label>
            <button class="control-button" id="companyQuannex">Quannex</button>
            <button class="control-button" id="companyNova">Nova Tech</button>
            <button class="control-button" id="companyZenith">Zenith Solutions</button>
            <button class="control-button" id="companyApex">Apex Industries</button>
        </div>

        <div class="control-group">
            <label class="control-label">Global Stats</label>
            <div class="stats-item">
                <span class="stats-label">Coherence</span>
                <span class="stats-value" id="statCoherence">--</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Status</span>
                <span class="stats-value" id="statStatus">--</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Faces</span>
                <span class="stats-value">12</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Edges</span>
                <span class="stats-value">30</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Instructions</label>
            <div style="font-size: 11px; opacity: 0.7; line-height: 1.6;">
                â€¢ <strong>Hover</strong> over faces for info<br>
                â€¢ <strong>Click</strong> faces for details<br>
                â€¢ <strong>Drag</strong> to rotate manually<br>
                â€¢ <strong>Scroll</strong> to zoom in/out<br>
                â€¢ <strong>R</strong> - Reset camera view<br>
                â€¢ <strong>Space</strong> - Toggle rotation<br>
                â€¢ <strong>ESC</strong> - Close panels
            </div>
        </div>
    </div>

    <!-- Analysis Panel (Advanced/Complete Modes) -->
    <div class="analysis-panel" id="analysisPanel">
        <div id="analysisContent">
            <!-- Will be populated by JavaScript -->
        </div>
    </div>

    <!-- Legend -->
    <div class="legend" id="legend">
        <div class="legend-title">Face Energy</div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #00ff88, #00ffcc);"></div>
            <span>Healthy (70-100%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #ffa500, #ffcc00);"></div>
            <span>Warning (40-70%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #ff4444, #ff6b6b);"></div>
            <span>Critical (0-40%)</span>
        </div>
    </div>

    <!-- Face Detail Panel -->
    <div class="face-detail-panel" id="faceDetailPanel">
        <div class="face-detail-header">
            <div class="face-detail-title" id="faceDetailTitle">Face Name</div>
            <button class="face-detail-close" id="closeFaceDetail">&times;</button>
        </div>

        <div class="face-energy-display" id="faceEnergyDisplay">--</div>
        <div class="face-energy-label">FACE ENERGY</div>

        <div class="kpi-grid" id="kpiGrid">
            <!-- KPIs will be injected here -->
        </div>

        <!-- Connected Edges Section -->
        <div class="analysis-section" id="connectedEdgesSection" style="display: none;">
            <div class="section-title">ðŸ”— Connected Edges</div>
            <div id="connectedEdgesList">
                <!-- Edges will be injected here -->
            </div>
        </div>

        <!-- Corner Vertices Section -->
        <div class="analysis-section" id="cornerVerticesSection" style="display: none;">
            <div class="section-title">ðŸŒ€ Corner Vortices</div>
            <div id="cornerVerticesList">
                <!-- Vertices will be injected here -->
            </div>
        </div>
    </div>

    <!-- Hover Tooltip (Faces) -->
    <div class="face-tooltip" id="faceTooltip">
        <div class="tooltip-face-name" id="tooltipFaceName">Face Name</div>
        <div class="tooltip-energy">
            Energy: <span class="tooltip-energy-value" id="tooltipEnergyValue">--</span>
        </div>
        <div class="tooltip-hint">Click to view details</div>
    </div>

    <!-- Edge Tooltip -->
    <div class="edge-tooltip" id="edgeTooltip">
        <!-- Content will be dynamically injected -->
    </div>

    <!-- Vertex Tooltip -->
    <div class="edge-tooltip" id="vertexTooltip" style="border-color: rgba(255, 0, 100, 0.6); box-shadow: 0 4px 20px rgba(255, 0, 100, 0.3);">
        <!-- Content will be dynamically injected -->
    </div>

    <!-- Three.js Library -->
    <script src="https://unpkg.com/three@0.128.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Load breath analyzer first -->
    <script src="js/breath-analyzer.js"></script>
    
    <!-- Load spectral analyzer (required for engine) -->
    <script src="js/spectral-analyzer.js"></script>

    <!-- Main Quannex Engine (modules) -->
    <script type="module" src="js/main.js"></script>
    <script type="module" src="js/company-loader.js"></script>

    <!-- Dodecahedron Visualization -->
    <script src="js/dodecahedron-viz.js"></script>

    <script type="module">
        // Import advanced analyzers (lazy loaded when needed)
        let SpectralAnalyzer, EdgeAnalyzer, VertexAnalyzer, ShadowDetector, DynamicsAnalyzer, AIEdgeInterpreter;
        let analyzersLoaded = false;

        async function loadAdvancedAnalyzers() {
            if (analyzersLoaded) return;

            try {
                const modules = await Promise.all([
                    import('./js/advanced/spectral-analyzer.js'),
                    import('./js/advanced/edge-analyzer.js'),
                    import('./js/advanced/vertex-analyzer.js?v=2'),
                    import('./js/advanced/shadow-detector.js'),
                    import('./js/advanced/ai-edge-interpreter.js'),
                ]);

                SpectralAnalyzer = modules[0].SpectralAnalyzer;
                EdgeAnalyzer = modules[1].EdgeAnalyzer;
                VertexAnalyzer = modules[2].VertexAnalyzer;
                ShadowDetector = modules[3].ShadowDetector;
                AIEdgeInterpreter = modules[4].AIEdgeInterpreter;

                analyzersLoaded = true;
                console.log('âœ… Advanced analyzers loaded (including AI Edge Interpreter)');
            } catch (error) {
                console.error('âŒ Failed to load analyzers:', error);
            }
        }

        async function loadDynamicsAnalyzer() {
            if (DynamicsAnalyzer) return;

            try {
                const module = await import('./js/advanced/dynamics-analyzer.js');
                DynamicsAnalyzer = module.DynamicsAnalyzer;
                console.log('âœ… Dynamics analyzer loaded');
            } catch (error) {
                console.error('âŒ Failed to load dynamics analyzer:', error);
            }
        }

        // Global state
        let currentMode = 'standard';
        let currentLoadedCompanyId = null;
        let edgeLines = [];
        let vertexSpheres = [];
        let feedbackLoopLines = [];
        let advancedAnalysisResults = null;

        // Mode switching
        window.switchMode = async function(mode) {
            console.log(`ðŸ”„ Switching to ${mode} mode`);
            currentMode = mode;

            // Update UI
            updateModeUI(mode);

            // Load required analyzers
            if (mode === 'advanced' || mode === 'complete') {
                await loadAdvancedAnalyzers();
            }
            if (mode === 'complete') {
                await loadDynamicsAnalyzer();
            }

            // Update visualization with mode-specific features
            await updateVisualizationForMode(mode);
        };

        // Advanced visualization update
        async function updateVisualizationForMode(mode) {
            const scene = window.scene;
            if (!scene) {
                console.warn('âš ï¸ Scene not ready yet');
                return;
            }

            // Clear existing advanced visualizations
            clearAdvancedVisualizations();

            if (mode === 'standard' || mode === 'minimal') {
                // Base visualization only
                advancedAnalysisResults = null;
                window.advancedAnalysisResults = null;
                console.log('âœ… Standard/Minimal mode - base visualization active');
                return;
            }

            // Get company data
            const companyData = window.Quannex ? window.Quannex.getState() : null;
            if (!companyData || !companyData.faces) {
                console.warn('âš ï¸ No company data available');
                return;
            }

            // Run analyses
            const faceEnergies = companyData.faces.map(f => f.faceEnergy);

            if (mode === 'advanced') {
                await runAdvancedAnalysis(companyData, faceEnergies);
                renderEdgeTensions();
                renderVertexVortices();
                updateAnalysisPanel();
            } else if (mode === 'complete') {
                await runCompleteAnalysis(companyData, faceEnergies);
                renderEdgeTensions();
                renderVertexVortices();
                renderFeedbackLoops();
                updateAnalysisPanel();
            }
        }

        // Clear all advanced visualizations
        function clearAdvancedVisualizations() {
            const scene = window.scene;
            if (!scene) return;

            // Remove edge lines
            if (window.edgeLines) {
                window.edgeLines.forEach(line => scene.remove(line));
                window.edgeLines = [];
            }

            // Remove vertex spheres
            if (window.vertexSpheres) {
                window.vertexSpheres.forEach(sphere => scene.remove(sphere));
                window.vertexSpheres = [];
            }

            // Remove feedback loops
            if (window.feedbackLoopLines) {
                window.feedbackLoopLines.forEach(line => scene.remove(line));
                window.feedbackLoopLines = [];
            }
        }

        // Run advanced analysis (spectral + edge + vertex + shadow)
        async function runAdvancedAnalysis(companyData, faceEnergies) {
            if (!analyzersLoaded) {
                console.warn('âš ï¸ Analyzers not loaded yet');
                return;
            }

            const spectral = new SpectralAnalyzer();
            const edges = new EdgeAnalyzer();
            const vertices = new VertexAnalyzer();
            const shadows = new ShadowDetector();
            const aiInterpreter = new AIEdgeInterpreter(); // ðŸ§  The Brain

            // Load CSV edge tension data for rich metadata
            console.log('ðŸ“Š Loading edge tension CSV data...');
            await edges.loadEdgeCSV('./data/CSV_Edge_tension_Map.csv');
            
            // Load CSV vertex data for rich metadata
            console.log('ðŸ“Š Loading vertex vortex CSV data...');
            await vertices.loadVertexCSV('./data/CSV_Vortex_Map.csv');
            
            // Load spectral data if available
            const spectralAnalysis = spectral.analyze(faceEnergies);
            
            // Calculate base edges
            let edgeAnalysis = edges.calculateAllEdges(companyData.faces);
            
            // ðŸ§  ENHANCE WITH AI INTERPRETATION
            // This adds the "Story" to the "Physics"
            console.log('ðŸ§  Running AI Edge Interpreter...');
            edgeAnalysis = edgeAnalysis.map(edge => {
                // Get face objects
                const face1 = companyData.faces.find(f => f.id === edge.face1Id);
                const face2 = companyData.faces.find(f => f.id === edge.face2Id);
                
                // Generate AI metadata (Archetype, Question, KPI)
                // Pass existing CSV data if available to fill gaps
                const csvData = edge.hasCSVData ? {
                    archetype: edge.archetype,
                    question: edge.question,
                    kpiName: edge.kpiName,
                    kpiMetric: edge.kpiMetric,
                    kpiCalculation: edge.kpiCalculation
                } : null;
                
                const aiMeta = aiInterpreter.generateEdgeMetadata(face1, face2, edge.element, csvData);
                
                // Merge into edge object
                return {
                    ...edge,
                    ...aiMeta, // Overwrites/fills archetype, question, kpiName, etc.
                    aiSource: aiMeta.source
                };
            });

            const vertexAnalysis = vertices.calculateAllVertices(companyData.faces);
            const shadowAnalysis = shadows.analyze(companyData.faces, companyData.kpis);

            advancedAnalysisResults = {
                spectral: spectralAnalysis,
                edges: edgeAnalysis,
                vertices: vertexAnalysis,
                shadows: shadowAnalysis
            };

            // Expose to window for dodecahedron-viz.js access
            window.advancedAnalysisResults = advancedAnalysisResults;

            console.log('âœ… Advanced analysis complete (with CSV edge data)');
        }

        // Run complete analysis (advanced + dynamics)
        async function runCompleteAnalysis(companyData, faceEnergies) {
            await runAdvancedAnalysis(companyData, faceEnergies);

            if (!DynamicsAnalyzer) {
                console.warn('âš ï¸ Dynamics analyzer not loaded');
                return;
            }

            const dynamics = new DynamicsAnalyzer();
            const dynamicsAnalysis = dynamics.analyzeComplete(
                companyData.faces,
                advancedAnalysisResults.edges,
                advancedAnalysisResults.spectral
            );

            advancedAnalysisResults.dynamics = dynamicsAnalysis;

            // Update window reference
            window.advancedAnalysisResults = advancedAnalysisResults;

            console.log('âœ… Complete dynamics analysis done');
        }

        // Render edge tensions as NEON TUBES along geometric edges
        function renderEdgeTensions() {
            if (!advancedAnalysisResults || !advancedAnalysisResults.edges) {
                console.warn('âš ï¸ No edge analysis data available');
                return;
            }

            const scene = window.scene;
            const edges = advancedAnalysisResults.edges;
            const companyData = window.Quannex ? window.Quannex.getState() : null;

        // Initialize/clear global edgeLines array for raycasting
        if (!window.edgeLines) {
            window.edgeLines = [];
        } else {
            // Clear existing edge meshes from scene
            window.edgeLines.forEach(mesh => scene.remove(mesh));
            window.edgeLines = [];
        }

        // EDGE ANALYZER INSTANCE (Needed for narrative generation)
        const edgeAnalyzer = new EdgeAnalyzer();

        console.log(`ðŸŽ¨ Rendering ${edges.length} neon edge tubes on dodecahedron surface...`);

        let successfulEdges = 0;
        let skippedEdges = 0;

        edges.forEach(edge => {
            // Find the 2 shared vertex positions directly from face geometries
            const sharedPositions = findSharedEdgeVertices(edge.face1Id, edge.face2Id);

            if (!sharedPositions || sharedPositions.length !== 2) {
                console.warn(`âš ï¸ Cannot find shared edge for ${edge.id} (Face ${edge.face1Id}-${edge.face2Id})`);
                skippedEdges++;
                return;
            }

            const vertex1 = sharedPositions[0];
            const vertex2 = sharedPositions[1];

        // ðŸŽ¯ SMART EDGE NAMING SYSTEM
            // Now powered by AI Interpreter
            let edgeName = edge.archetype; // AI Interpreter ensures this is always populated
            let face1Name = edge.face1Name;
            let face2Name = edge.face2Name;

            // ðŸ“– GENERATE NARRATIVE (Enhanced with AI Context)
            // We pass the enriched edge object which now has kpiName, question, etc.
            const narrative = edgeAnalyzer.generateNarrative(edge);
            
            // Add AI specific fields to narrative if not present
            narrative.kpiSuggestion = edge.kpiName;
            narrative.kpiMetric = edge.kpiMetric;
            narrative.aiSource = edge.aiSource;

            // === NEON TUBE GEOMETRY ON SURFACE ===
            // Create glowing tube between the two shared vertices

            // Create path between geometric vertices
            const curve = new THREE.LineCurve3(vertex1, vertex2);

            // Tube radius based on tension: 0.025 (low) -> 0.045 (high)
            // Slightly thicker for visibility
            const tubeRadius = 0.025 + (edge.tension * 0.02);
            const tubeGeometry = new THREE.TubeGeometry(curve, 2, tubeRadius, 8, false);

            // Parse color from edge.color (hex string from EdgeAnalyzer)
            const colorValue = new THREE.Color(edge.color || '#00ff88');

            // NEON GLOW SETTINGS
            const baseOpacity = 0.9 + (edge.tension * 0.05); // 90-95% visible
            const pulseSpeed = 1000 / (1 + edge.tension * 3); // High tension = faster pulse
            const emissiveIntensity = 0.5 + (edge.tension * 0.4); // 0.5 (low) -> 0.9 (high)

            // MeshPhongMaterial for neon effect
            const material = new THREE.MeshPhongMaterial({
                color: colorValue,
                emissive: colorValue,
                emissiveIntensity: emissiveIntensity,
                transparent: true,
                opacity: baseOpacity,
                shininess: 100, // High shininess for neon look
                side: THREE.DoubleSide
            });

            const tubeMesh = new THREE.Mesh(tubeGeometry, material);
            tubeMesh.renderOrder = 10; // Render edges ON TOP of everything

            // Store comprehensive edge data for interaction
            tubeMesh.userData.edgeData = edge;
            tubeMesh.userData.edgeName = edgeName;
            tubeMesh.userData.narrative = narrative; // STORE NARRATIVE HERE
            tubeMesh.userData.face1Name = face1Name;
            tubeMesh.userData.face2Name = face2Name;
            tubeMesh.userData.isEdge = true; // Mark as edge for raycasting
            tubeMesh.userData.animation = {
                baseOpacity: baseOpacity,
                baseEmissive: emissiveIntensity,
                pulseSpeed: pulseSpeed,
                startTime: Date.now(),
                pulseAmplitude: 0.1 // Subtle pulse
            };

            scene.add(tubeMesh);
            window.edgeLines.push(tubeMesh);
            successfulEdges++;
        });

        console.log(`âœ… Rendered ${successfulEdges} neon edge tubes (${skippedEdges} skipped)`);

        // Start animation loop if not already running
        if (window.edgeLines.length > 0 && !window.edgeAnimationRunning) {
            animateEdges();
        }
    }

    // Handle Edge & Vertex Raycasting (Narrative Tooltip)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const edgeTooltip = document.getElementById('edgeTooltip');
    const vertexTooltip = document.getElementById('vertexTooltip');

    window.addEventListener('mousemove', (event) => {
        if ((!window.edgeLines || window.edgeLines.length === 0) && (!window.vertexSpheres || window.vertexSpheres.length === 0)) return;
        
        // Only check if canvas is visible
        const canvas = document.getElementById('scene');
        if (!canvas) return;

        // Normalized mouse coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Raycast against edge lines AND vertices
        raycaster.setFromCamera(mouse, window.camera);
        
        // Increase threshold for easier selection of thin lines
        raycaster.params.Line.threshold = 0.1; 
        
        // Combine interaction targets
        const targets = [...(window.edgeLines || []), ...(window.vertexSpheres || [])];
        const intersects = raycaster.intersectObjects(targets);

        if (intersects.length > 0) {
            const object = intersects[0].object;
            const data = object.userData;
            
            if (data.isEdge) {
                // Hide vertex tooltip
                if (vertexTooltip) vertexTooltip.classList.remove('visible');

                const narrative = data.narrative;

                // Show Edge Tooltip (Enhanced AI Layout)
                if (edgeTooltip) {
                    edgeTooltip.innerHTML = `
                        <div style="font-weight: bold; color: #00ffcc; margin-bottom: 2px; font-size: 13px;">${data.edgeName}</div>
                        <div style="font-size: 9px; color: rgba(255,255,255,0.5); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">
                            ${data.face1Name} â†” ${data.face2Name}
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                            <div style="font-size: 10px; color: #aaa; margin-bottom: 2px;">Strategic Question:</div>
                            <div style="font-size: 11px; font-style: italic; color: #fff;">"${narrative.question}"</div>
                        </div>

                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 4px;">
                            <span>Tension:</span>
                            <span style="color: ${data.edgeData.tension > 0.6 ? '#ff4444' : '#00ff88'}">${(data.edgeData.tension * 100).toFixed(0)}% (${narrative.tensionStatus})</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 8px;">
                            <span>Flow:</span>
                            <span style="color: #00ccff;">${narrative.flow}</span>
                        </div>

                        <div style="font-size: 11px; line-height: 1.4; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                            ${narrative.fullNarrative}
                        </div>
                        
                        ${narrative.kpiSuggestion ? `
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px dashed rgba(255,255,255,0.1);">
                            <div style="font-size: 9px; color: #00ffcc; text-transform: uppercase;">Recommended KPI</div>
                            <div style="font-size: 11px; font-weight: 600;">${narrative.kpiSuggestion}</div>
                            <div style="font-size: 10px; opacity: 0.7;">${narrative.kpiMetric}</div>
                        </div>
                        ` : ''}
                    `;
                    
                    edgeTooltip.style.left = (event.clientX + 15) + 'px';
                    edgeTooltip.style.top = (event.clientY + 15) + 'px';
                    edgeTooltip.classList.add('visible');
                }
                
                // Highlight Effect
                document.body.style.cursor = 'help';
                object.material.emissiveIntensity = 2.0; // Super glow on hover

            } else if (data.isVertex) {
                // Hide edge tooltip
                if (edgeTooltip) edgeTooltip.classList.remove('visible');

                const vertex = data.vertexData;
                const narrative = data.narrative;

                // Show Vertex Tooltip
                if (vertexTooltip) {
                    vertexTooltip.innerHTML = `
                        <div style="font-weight: bold; color: #ff0066; margin-bottom: 2px; font-size: 13px;">${data.vertexName}</div>
                        <div style="font-size: 9px; color: rgba(255,255,255,0.5); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">
                            ${vertex.id} â€¢ Vortex Point
                        </div>

                        <div style="font-size: 10px; margin-bottom: 8px; display: flex; gap: 4px; flex-wrap: wrap;">
                            ${vertex.faceNames.map(name => `<span style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px;">${name}</span>`).join('')}
                        </div>

                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 4px;">
                            <span>Strength:</span>
                            <span style="color: ${vertex.vortexStrength > 0.7 ? '#ff0066' : '#00ffcc'}">${(vertex.vortexStrength * 100).toFixed(0)}% (${vertex.vortexType})</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 8px;">
                            <span>Coherence:</span>
                            <span style="color: ${vertex.coherence > 0.7 ? '#00ffcc' : '#ffaa00'}">${(vertex.coherence * 100).toFixed(0)}%</span>
                        </div>

                         <div style="background: rgba(255, 0, 100, 0.1); padding: 8px; border-radius: 6px; margin-bottom: 8px; border: 1px solid rgba(255, 0, 100, 0.3);">
                            <div style="font-size: 10px; color: #ff99cc; margin-bottom: 2px;">The Spin:</div>
                            <div style="font-size: 11px; color: #fff; font-style: italic;">"${narrative.spinLabel}"</div>
                             <div style="font-size: 11px; color: rgba(255,255,255,0.8); margin-top: 4px;">${narrative.description}</div>
                        </div>

                        <div style="font-size: 11px; line-height: 1.4; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                            <strong style="color: #ff0066;">Action:</strong> ${narrative.action}
                        </div>
                    `;

                    vertexTooltip.style.left = (event.clientX + 15) + 'px';
                    vertexTooltip.style.top = (event.clientY + 15) + 'px';
                    vertexTooltip.classList.add('visible');
                }

                // Highlight Effect
                document.body.style.cursor = 'help';
                object.material.opacity = 1.0; // Full opacity on hover
                object.scale.setScalar(1.3); // Grow slightly
            }

        } else {
            if (edgeTooltip) edgeTooltip.classList.remove('visible');
            if (vertexTooltip) vertexTooltip.classList.remove('visible');
            document.body.style.cursor = 'default';
            
            // Reset highlights
            window.edgeLines.forEach(mesh => {
                if (mesh.userData.animation) {
                    mesh.material.emissiveIntensity = mesh.userData.animation.baseEmissive;
                }
            });
            
            window.vertexSpheres.forEach(mesh => {
                mesh.material.opacity = 0.7; // Reset opacity
                mesh.scale.setScalar(1.0); // Reset scale
            });
        }
    });
        function animateEdges() {
            window.edgeAnimationRunning = true;

            function pulse() {
                const currentTime = Date.now();

                window.edgeLines.forEach(tubeMesh => {
                    if (!tubeMesh.userData.animation) return;

                    const { baseOpacity, baseEmissive, pulseSpeed, startTime, pulseAmplitude } = tubeMesh.userData.animation;
                    const elapsed = currentTime - startTime;

                    // Sin wave for smooth pulsation
                    const phase = (elapsed % pulseSpeed) / pulseSpeed * Math.PI * 2;
                    const pulseValue = Math.sin(phase) * pulseAmplitude;

                    // Animate both opacity and emissive intensity for dramatic effect
                    tubeMesh.material.opacity = baseOpacity + pulseValue;
                    tubeMesh.material.emissiveIntensity = baseEmissive + (pulseValue * 0.5);
                });

                // Continue animation if edges exist
                if (window.edgeLines.length > 0) {
                    requestAnimationFrame(pulse);
                } else {
                    window.edgeAnimationRunning = false;
                }
            }

            pulse();
        }

        // Render vertex vortices as colored spheres
        function renderVertexVortices() {
            if (!advancedAnalysisResults || !advancedAnalysisResults.vertices) return;

            const scene = window.scene;
            const vertices = advancedAnalysisResults.vertices;

            // Initialize/clear global vertexSpheres array
            if (!window.vertexSpheres) {
                window.vertexSpheres = [];
            } else {
                window.vertexSpheres.forEach(mesh => scene.remove(mesh));
                window.vertexSpheres = [];
            }

            console.log(`ðŸ“Š Rendering ${vertices.length} vertices`);

            // Debug first vertex structure
            if (vertices.length > 0) {
                console.log('First vertex structure:', vertices[0]);
            }

            // Track mapping collisions
            const geometricIndexMap = new Map();

            vertices.forEach((vertex, index) => {
                // Directly map vertex ID to geometric position
                const geometricIndex = getGeometricVertexIndex(vertex.id); // Fixed: use vertex.id, not vertex.vertexId
                const geometricVertices = getDodecahedronVertices();
                const position = geometricVertices[geometricIndex];

                // Track which analytical vertices map to which geometric indices
                if (!geometricIndexMap.has(geometricIndex)) {
                    geometricIndexMap.set(geometricIndex, []);
                }
                geometricIndexMap.get(geometricIndex).push({
                    vertexId: vertex.id,
                    archetype: vertex.archetype,
                    faceIds: vertex.faceIds
                });

                console.log(`Vertex ${vertex.id} (${vertex.archetype}): geoIdx=${geometricIndex}, pos=(${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}), faces=${JSON.stringify(vertex.faceIds)}`);
            });

            // Check for collisions (multiple analytical vertices mapping to same geometric vertex)
            console.log('\nðŸ” Checking for vertex mapping collisions:');
            let collisionCount = 0;
            geometricIndexMap.forEach((vertices, geoIdx) => {
                if (vertices.length > 1) {
                    collisionCount++;
                    console.warn(`âš ï¸ COLLISION at geometric index ${geoIdx}: ${vertices.length} analytical vertices mapped:`,
                        vertices.map(v => `#${v.vertexId}(${v.archetype})`).join(', '));
                }
            });
            console.log(`Total collisions detected: ${collisionCount}`);
            console.log(`Unique geometric positions used: ${geometricIndexMap.size} / ${getDodecahedronVertices().length}\n`);

            vertices.forEach((vertex, index) => {
                const geometricIndex = getGeometricVertexIndex(vertex.id);
                const geometricVertices = getDodecahedronVertices();
                const position = geometricVertices[geometricIndex];

                const radius = 0.15 + (vertex.vortexStrength * 0.15); // Increased size for visibility

                // Color by vortex direction (use vertex.vortexDirection, not vMean)
                let color;
                if (vertex.vortexDirection > 0.2) {
                    color = new THREE.Color(0x00ffcc); // Cyan (upward/positive spiral)
                } else if (vertex.vortexDirection > -0.2) {
                    color = new THREE.Color(0xffaa00); // Orange (neutral/turbulent)
                } else {
                    color = new THREE.Color(0xff4444); // Red (downward/negative spiral)
                }

                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5 + (vertex.vortexStrength * 0.5),
                    transparent: true,
                    opacity: 0.7
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);
                // Store full vertex data for interaction
                sphere.userData.vertexData = vertex;
                sphere.userData.isVertex = true;
                sphere.userData.isEdge = false;
                sphere.userData.vertexName = vertex.archetype;
                sphere.userData.narrative = vertex.narrative;
                
                scene.add(sphere);
                window.vertexSpheres.push(sphere);
            });

            console.log(`âœ… Rendered ${window.vertexSpheres.length} vortex spheres`);
        }

        // Render feedback loops (Complete mode only)
        function renderFeedbackLoops() {
            if (!advancedAnalysisResults || !advancedAnalysisResults.dynamics) return;

            const scene = window.scene;
            const loops = advancedAnalysisResults.dynamics.feedbackLoops.summary.criticalLoops || [];

            // Initialize/clear global feedbackLoopLines array
            if (!window.feedbackLoopLines) {
                window.feedbackLoopLines = [];
            } else {
                window.feedbackLoopLines.forEach(mesh => scene.remove(mesh));
                window.feedbackLoopLines = [];
            }

            loops.slice(0, 5).forEach((loop, index) => {
                const points = [];
                loop.cycle.forEach(faceId => {
                    const pos = getFaceCenterPosition(faceId - 1);
                    if (pos) points.push(pos);
                });

                // Close the loop
                if (points.length > 0) {
                    points.push(points[0]);
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);

                // Color by loop type
                let color;
                if (loop.direction.includes('Virtuous')) {
                    color = new THREE.Color(0x00ff88); // Green
                } else if (loop.direction.includes('Vicious')) {
                    color = new THREE.Color(0xff4444); // Red
                } else {
                    color = new THREE.Color(0xffaa00); // Orange
                }

                const material = new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.6
                });

                const line = new THREE.Line(geometry, material);
                line.userData.loopData = loop;
                scene.add(line);
                window.feedbackLoopLines.push(line);
            });

            console.log(`âœ… Rendered ${window.feedbackLoopLines.length} feedback loops`);
        }

        // Get face center position from actual rendered dodecahedron geometry
        function getFaceCenterPosition(faceIndex) {
            // Access actual face meshes from dodecahedron-viz.js
            const faceMeshes = window.dodecahedronViz?.faceMeshes;
            if (!faceMeshes) {
                console.warn(`âš ï¸ faceMeshes not available`);
                return null;
            }
            if (faceIndex >= faceMeshes.length) {
                console.warn(`âš ï¸ faceIndex ${faceIndex} out of bounds (max: ${faceMeshes.length - 1})`);
                return null;
            }
            if (faceIndex < 0) {
                console.warn(`âš ï¸ faceIndex ${faceIndex} is negative`);
                return null;
            }

            const mesh = faceMeshes[faceIndex];
            const geometry = mesh.geometry;
            const position = geometry.attributes.position;

            // Calculate centroid from actual vertices
            let x = 0, y = 0, z = 0;
            const count = position.count;

            for (let i = 0; i < count; i++) {
                x += position.getX(i);
                y += position.getY(i);
                z += position.getZ(i);
            }

            return new THREE.Vector3(x / count, y / count, z / count);
        }

        // Cache for extracted vertices and topology mapping
        let cachedGeometricVertices = null;
        let cachedVertexToFacesMap = null;
        let cachedAnalyticalToGeometricMap = null;

        // Get actual vertex positions and build face topology from Three.js dodecahedron
        window.getDodecahedronVertices = function() {
            // Return cached vertices if available
            if (cachedGeometricVertices) {
                return cachedGeometricVertices;
            }

            // Try to get the actual geometry from the rendered dodecahedron
            const dodecahedron = window.mainDodecahedron;

            if (dodecahedron && dodecahedron.geometry) {
                const positions = dodecahedron.geometry.attributes.position;
                const vertices = [];
                const uniqueVertices = new Map();

                // Extract unique vertices (Three.js may duplicate vertices for each face)
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);

                    // Round to avoid floating point precision issues
                    const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;

                    if (!uniqueVertices.has(key)) {
                        uniqueVertices.set(key, new THREE.Vector3(x, y, z));
                    }
                }

                // Convert map to array
                uniqueVertices.forEach(vertex => vertices.push(vertex));

                console.log(`âœ… Extracted ${vertices.length} unique vertices from Three.js geometry`);

                // Cache for future calls
                cachedGeometricVertices = vertices;
                return vertices;
            }

            // Fallback to theoretical positions if geometry not available
            console.warn('âš ï¸ Using fallback theoretical vertex positions');
            const phi = (1 + Math.sqrt(5)) / 2;
            const radius = 2;

            const fallbackVertices = [
                new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(radius),
                new THREE.Vector3(1, 1, -1).normalize().multiplyScalar(radius),
                new THREE.Vector3(1, -1, 1).normalize().multiplyScalar(radius),
                new THREE.Vector3(1, -1, -1).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1, 1, 1).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1, 1, -1).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1, -1, 1).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1, -1, -1).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, phi, 1/phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, phi, -1/phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, -phi, 1/phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, -phi, -1/phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(1/phi, 0, phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(1/phi, 0, -phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1/phi, 0, phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1/phi, 0, -phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(phi, 1/phi, 0).normalize().multiplyScalar(radius),
                new THREE.Vector3(phi, -1/phi, 0).normalize().multiplyScalar(radius),
                new THREE.Vector3(-phi, 1/phi, 0).normalize().multiplyScalar(radius),
                new THREE.Vector3(-phi, -1/phi, 0).normalize().multiplyScalar(radius)
            ];

            cachedGeometricVertices = fallbackVertices;
            return fallbackVertices;
        }

        // Authoritative vertex-to-face mapping extracted from Three.js geometry
        // This maps analytical vertex ID (1-20) to the 3 face IDs it connects
        // NOTE: This will be populated at runtime from the actual geometry
        let AUTHORITATIVE_VERTEX_TOPOLOGY = null;

        /**
         * Build a topology-aware mapping from Three.js face indices to analytical Face IDs
         * Returns an array where index = Three.js face index (0-11), value = analytical Face ID (1-12)
         */
        window.buildFaceIndexMapping = function() {
            console.log('\nðŸ”„ BUILDING TOPOLOGY-AWARE FACE MAPPING:');
            console.log('='.repeat(60));

            // Get the actual dodecahedron geometry
            const dodecahedron = window.mainDodecahedron;
            if (!dodecahedron || !dodecahedron.geometry) {
                console.error('âŒ Cannot build face mapping - dodecahedron not available');
                return null;
            }

            const geometry = dodecahedron.geometry;
            const position = geometry.attributes.position;
            const geometricVertices = getDodecahedronVertices();
            const vertexToFacesMap = buildVertexToFacesMap();

            if (!vertexToFacesMap) {
                console.error('âŒ Cannot build face mapping - vertex topology not available');
                return null;
            }

            const mapping = [];

            // For each of the 12 faces in Three.js geometry
            for (let faceIdx = 0; faceIdx < 12; faceIdx++) {
                // Each face is 3 triangles = 9 vertices
                const start = faceIdx * 9;
                const faceVertexIndices = new Set();

                // Extract unique geometric vertex indices for this face
                if (geometry.index) {
                    // Indexed geometry
                    for (let i = 0; i < 9; i++) {
                        const idx = geometry.index.getX(start + i);
                        faceVertexIndices.add(idx);
                    }
                } else {
                    // Non-indexed - match by position
                    for (let i = 0; i < 9; i++) {
                        const vx = position.getX(start + i);
                        const vy = position.getY(start + i);
                        const vz = position.getZ(start + i);

                        // Find matching geometric vertex
                        for (let geoIdx = 0; geoIdx < geometricVertices.length; geoIdx++) {
                            const geoV = geometricVertices[geoIdx];
                            const dist = Math.sqrt(
                                Math.pow(vx - geoV.x, 2) +
                                Math.pow(vy - geoV.y, 2) +
                                Math.pow(vz - geoV.z, 2)
                            );
                            if (dist < 0.01) {
                                faceVertexIndices.add(geoIdx);
                                break;
                            }
                        }
                    }
                }

                // Now we have the geometric vertex indices for this face
                // Find which analytical face ID appears in ALL vertices' connected faces
                const vertexFaceSets = Array.from(faceVertexIndices).map(geoIdx =>
                    vertexToFacesMap.get(geoIdx) || new Set()
                );

                // Find the common face ID across all vertices
                let commonFaceId = null;
                if (vertexFaceSets.length > 0) {
                    const firstSet = vertexFaceSets[0];
                    for (const faceId of firstSet) {
                        if (vertexFaceSets.every(set => set.has(faceId))) {
                            commonFaceId = faceId;
                            break;
                        }
                    }
                }

                mapping[faceIdx] = commonFaceId;
                console.log(`Geometry Face ${faceIdx + 1} (${faceVertexIndices.size} vertices) â†’ Analytical Face ${commonFaceId}`);
            }

            console.log('='.repeat(60));
            console.log(`âœ… Built face mapping for all 12 faces\n`);

            return mapping;
        }

        /**
         * Extract the ACTUAL vertex topology from the rendered Three.js geometry
         * This is the ground truth - what the dodecahedron actually looks like
         */
        function extractActualTopologyFromGeometry() {
            const vertexToFacesMap = buildVertexToFacesMap();

            if (!vertexToFacesMap || vertexToFacesMap.size === 0) {
                console.error('âŒ Could not extract topology from geometry - no face meshes available');
                return null;
            }

            console.log('\nðŸ” EXTRACTED ACTUAL TOPOLOGY FROM THREE.JS GEOMETRY:');
            console.log('='.repeat(60));

            const topology = {};
            vertexToFacesMap.forEach((faceSet, geoIdx) => {
                const faces = Array.from(faceSet).sort((a, b) => a - b);
                topology[geoIdx] = faces;
                console.log(`Vertex ${geoIdx + 1}: faces [${faces.join(', ')}] (${faces.length} faces)`);
            });

            console.log('='.repeat(60));
            console.log(`âœ… Extracted ${Object.keys(topology).length} vertices from actual geometry\n`);

            // Validate topology
            const vertexCount = Object.keys(topology).length;
            const invalidVertices = Object.entries(topology).filter(([, faces]) => faces.length !== 3);

            if (vertexCount !== 20) {
                console.error(`âŒ ERROR: Expected 20 vertices, got ${vertexCount}`);
            }

            if (invalidVertices.length > 0) {
                console.error(`âŒ ERROR: ${invalidVertices.length} vertices don't have exactly 3 faces:`);
                invalidVertices.forEach(([idx, faces]) => {
                    console.error(`   Vertex ${parseInt(idx) + 1}: ${faces.length} faces - [${faces.join(', ')}]`);
                });
            }

            if (vertexCount === 20 && invalidVertices.length === 0) {
                console.log('âœ… VALIDATION PASSED: All 20 vertices have exactly 3 faces');
            }

            return topology;
        }

        /**
         * Build the authoritative vertex-to-face topology
         * Uses ACTUAL geometry as ground truth, then maps to analytical vertex IDs
         */
        function buildAuthoritativeTopology() {
            // Extract actual topology from rendered geometry
            const geometricTopology = extractActualTopologyFromGeometry();

            if (!geometricTopology) {
                console.warn('âš ï¸ Geometry extraction failed, using CSV fallback topology');
                // Return CSV topology as fallback
                return {
                    1: [1, 2, 6],     // V1: Foundation Nexus
                    2: [1, 5, 6],     // V2: Resource Core
                    3: [1, 8, 9],     // V3: Action Point
                    4: [2, 9, 10],    // V4: Growth Catalyst
                    5: [2, 3, 10],    // V5: Development Hub
                    6: [2, 3, 6],     // V6: Social Nexus
                    7: [3, 10, 11],   // V7: Learning Junction
                    8: [4, 5, 6],     // V8: Brand Anchor
                    9: [1, 5, 8],     // V9: Strategic Vortex
                    10: [4, 5, 7],    // V10: Excellence Hub
                    11: [3, 4, 11],   // V11: Governance Core
                    12: [4, 7, 11],   // V12: Leadership Point
                    13: [5, 7, 8],    // V13: Vision Bridge
                    14: [7, 8, 12],   // V14: Future Nexus
                    15: [7, 11, 12],  // V15: Wisdom Center
                    16: [8, 9, 12],   // V16: Impact Junction
                    17: [9, 10, 12],  // V17: Evolution Point
                    18: [10, 11, 12], // V18: Sustainability Anchor
                    19: [3, 4, 6],    // V19: Culture Nexus
                    20: [1, 2, 9]     // V20: Wisdom Center
                };
            }

            // For now, use geometric indices as analytical IDs (geoIdx + 1 = analyticalId)
            // This will show us the ACTUAL topology, then we can map archetypes to it
            const topology = {};
            Object.entries(geometricTopology).forEach(([geoIdx, faces]) => {
                const analyticalId = parseInt(geoIdx) + 1; // Convert to 1-indexed
                topology[analyticalId] = faces;
            });

            console.log('ðŸ“Š Using EXTRACTED topology as authoritative source');
            return topology;
        }

        /**
         * Get the authoritative vertex topology, building it if not yet initialized
         */
        function getAuthoritativeTopology() {
            if (!AUTHORITATIVE_VERTEX_TOPOLOGY) {
                AUTHORITATIVE_VERTEX_TOPOLOGY = buildAuthoritativeTopology();
            }
            return AUTHORITATIVE_VERTEX_TOPOLOGY;
        }

        /**
         * Find the 2 vertices that form the shared edge between two faces
         * @param {number} face1 - First face ID (1-12)
         * @param {number} face2 - Second face ID (1-12)
         * @returns {Array<number>} Array of 2 vertex IDs, or null if faces don't share an edge
         */
        function findSharedEdgeVertices(face1Id, face2Id) {
            // Get the authoritative topology (builds from geometry if not yet initialized)
            const topology = getAuthoritativeTopology();
            const sharedVertexIds = [];

            // Check each vertex (1-20) to see if it connects to both faces
            for (let vertexId = 1; vertexId <= 20; vertexId++) {
                const connectedFaces = topology[vertexId];

                if (!connectedFaces) continue;

                // If this vertex connects to both faces, it's part of the shared edge
                if (connectedFaces.includes(face1Id) && connectedFaces.includes(face2Id)) {
                    sharedVertexIds.push(vertexId);
                }
            }

            // Two adjacent faces should share exactly 2 vertices
            if (sharedVertexIds.length !== 2) {
                console.warn(`âš ï¸ Faces ${face1Id} and ${face2Id} share ${sharedVertexIds.length} vertices (expected 2)`);
                return null;
            }

            // Convert vertex IDs to geometric positions
            const geometricVertices = getDodecahedronVertices();
            const sharedPositions = sharedVertexIds.map(vertexId => {
                const geoIndex = getGeometricVertexIndex(vertexId);
                return geometricVertices[geoIndex];
            });

            // Verify we got valid positions
            if (!sharedPositions[0] || !sharedPositions[1]) {
                console.warn(`âš ï¸ Could not map vertex IDs ${sharedVertexIds} to positions for edge ${face1Id}-${face2Id}`);
                return null;
            }

            return sharedPositions; // Returns array of 2 THREE.Vector3 positions
        }

        // Build a map of geometric vertex index -> face indices
        window.buildVertexToFacesMap = function() {
            if (cachedVertexToFacesMap) {
                return cachedVertexToFacesMap;
            }

            const faceMeshes = window.dodecahedronViz?.faceMeshes;
            const geometricVertices = getDodecahedronVertices();

            if (!faceMeshes || faceMeshes.length === 0) {
                console.warn('âš ï¸ No face meshes available for topology mapping');
                return null;
            }

            // Map: geometricVertexIndex -> Set of faceIndices (1-12, 1-indexed to match authoritative data)
            const vertexToFaces = new Map();

            // For each geometric vertex, find which faces it belongs to
            geometricVertices.forEach((geoVertex, geoIdx) => {
                const connectedFaces = new Set();

                // Check each face mesh
                faceMeshes.forEach((mesh, faceIdx) => {
                    const positions = mesh.geometry.attributes.position;

                    // Check if this face contains this vertex
                    for (let i = 0; i < positions.count; i++) {
                        const vx = positions.getX(i);
                        const vy = positions.getY(i);
                        const vz = positions.getZ(i);

                        // Check if this face vertex matches the geometric vertex
                        const distance = Math.sqrt(
                            Math.pow(vx - geoVertex.x, 2) +
                            Math.pow(vy - geoVertex.y, 2) +
                            Math.pow(vz - geoVertex.z, 2)
                        );

                        if (distance < 0.01) { // Tolerance for floating point comparison
                            connectedFaces.add(faceIdx + 1); // +1 because analytical faces are 1-indexed
                            break;
                        }
                    }
                });

                if (connectedFaces.size > 0) {
                    vertexToFaces.set(geoIdx, connectedFaces);
                }
            });

            console.log(`âœ… Built vertex-to-faces topology map for ${vertexToFaces.size} vertices`);

            cachedVertexToFacesMap = vertexToFaces;
            return vertexToFaces;
        }

        // Find the geometric vertex index by matching face connectivity
        function getGeometricVertexIndex(vertexId) {
            // Check if we already have a cached mapping
            if (!cachedAnalyticalToGeometricMap) {
                cachedAnalyticalToGeometricMap = new Map();
            }

            if (cachedAnalyticalToGeometricMap.has(vertexId)) {
                return cachedAnalyticalToGeometricMap.get(vertexId);
            }

            // Use authoritative topology data extracted from geometry
            const topology = getAuthoritativeTopology();
            const authoritativeFaces = topology[vertexId];

            if (!authoritativeFaces) {
                console.warn(`âš ï¸ No authoritative topology data for vertex ${vertexId}`);
                return 0;
            }

            // Build vertex-to-faces topology map if not already built
            const vertexToFaces = buildVertexToFacesMap();

            if (!vertexToFaces) {
                console.warn('âš ï¸ Topology mapping failed, using fallback');
                // Fallback to proximity-based method
                if (advancedAnalysisResults && advancedAnalysisResults.vertices) {
                    const vertex = advancedAnalysisResults.vertices.find(v => v.id === vertexId);
                    if (vertex) {
                        return getGeometricVertexIndexByProximity(vertex);
                    }
                }
                return 0;
            }

            // Convert authoritative face IDs to a Set for comparison
            const authoritativeFaceSet = new Set(authoritativeFaces);

            // Find the geometric vertex whose face connectivity matches the authoritative data
            let bestMatch = null;
            let bestMatchScore = 0;

            vertexToFaces.forEach((geoFaces, geoIdx) => {
                // Skip if already mapped to another analytical vertex
                const alreadyMapped = Array.from(cachedAnalyticalToGeometricMap.values()).includes(geoIdx);
                if (alreadyMapped) return;

                // Calculate match score (how many faces match)
                let matchCount = 0;
                authoritativeFaceSet.forEach(faceId => {
                    if (geoFaces.has(faceId)) {
                        matchCount++;
                    }
                });

                // Perfect match requires all 3 faces to match
                if (matchCount === 3 && geoFaces.size === 3) {
                    bestMatch = geoIdx;
                    bestMatchScore = 3;
                } else if (matchCount > bestMatchScore) {
                    // Partial match - take the best one
                    bestMatch = geoIdx;
                    bestMatchScore = matchCount;
                }
            });

            const finalIndex = bestMatch !== null ? bestMatch : 0;
            cachedAnalyticalToGeometricMap.set(vertexId, finalIndex);

            console.log(`ðŸ“ Vertex ${vertexId}: authoritative faces ${JSON.stringify(authoritativeFaces)} â†’ geometric index ${finalIndex} (match score: ${bestMatchScore})`);

            return finalIndex;
        }

        // Fallback: Find geometric vertex by proximity (old method)
        function getGeometricVertexIndexByProximity(vertex) {
            // Get the centers of the 3 faces that meet at this vertex
            const faceCenters = vertex.faceIds.map(faceId => getFaceCenterPosition(faceId - 1)).filter(p => p !== null);
            if (faceCenters.length !== 3) return 0;

            // Calculate the average position (approximate vertex location)
            const avgPos = new THREE.Vector3();
            faceCenters.forEach(center => avgPos.add(center));
            avgPos.divideScalar(faceCenters.length);

            // Find the closest actual vertex from the Three.js geometry
            const geometricVertices = getDodecahedronVertices();
            let closestIndex = 0;
            let minDistance = Infinity;

            geometricVertices.forEach((geoVertex, index) => {
                const distance = avgPos.distanceTo(geoVertex);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });

            return closestIndex;
        }

        // Get vertex position using actual geometric vertices
        function getVertexPosition(vertexFaceIds) {
            // Find which vertex this is by matching face IDs
            if (!advancedAnalysisResults || !advancedAnalysisResults.vertices) return null;

            const vertex = advancedAnalysisResults.vertices.find(v =>
                v.faceIds.length === vertexFaceIds.length &&
                v.faceIds.every(id => vertexFaceIds.includes(id))
            );

            if (!vertex) return null;

            // Map to geometric vertex and get position
            const geometricIndex = getGeometricVertexIndex(vertex.id); // Fixed: use vertex.id
            const geometricVertices = getDodecahedronVertices();

            return geometricVertices[geometricIndex];
        }

        // Update analysis panel with current results
        function updateAnalysisPanel() {
            if (!advancedAnalysisResults) return;

            const content = document.getElementById('analysisContent');
            const { spectral, edges, vertices, shadows, dynamics } = advancedAnalysisResults;

            let html = `
                <!-- Spectral Analysis -->
                <div class="analysis-section">
                    <div class="section-title">ðŸŽµ Spectral Mode</div>
                    <div class="metric-row">
                        <span class="metric-label">Pattern</span>
                        <span class="metric-value">${spectral.summary.pattern}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Eigenvalue Î»</span>
                        <span class="metric-value">${spectral.dominantMode.eigenvalue.toFixed(3)}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Dissonance</span>
                        <span class="metric-value ${spectral.diagnostics.dissonanceIndex.percentage > 20 ? 'critical' : 'success'}">
                            ${spectral.diagnostics.dissonanceIndex.percentage.toFixed(1)}%
                        </span>
                    </div>
                </div>

                <!-- Edge Tensions -->
                <div class="analysis-section">
                    <div class="section-title">ðŸ”— Edge Tensions</div>
                    <div class="metric-row">
                        <span class="metric-label">Total Edges</span>
                        <span class="metric-value">${edges.length}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">High Tension</span>
                        <span class="metric-value">${edges.filter(e => e.tension > 0.4).length} edges</span>
                    </div>
                </div>

                <!-- Vortex Dynamics -->
                <div class="analysis-section">
                    <div class="section-title">ðŸŒ€ Vortex Dynamics</div>
                    <div class="metric-row">
                        <span class="metric-label">Total Vertices</span>
                        <span class="metric-value">${vertices.length}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Strong Vortices</span>
                        <span class="metric-value">${vertices.filter(v => v.vortexStrength > 0.5).length}</span>
                    </div>
                </div>

                <!-- Shadow Detection -->
                <div class="analysis-section">
                    <div class="section-title">ðŸ‘ï¸ Shadow Patterns</div>
                    <div class="metric-row">
                        <span class="metric-label">Detected</span>
                        <span class="metric-value ${shadows.totalPatternsDetected > 0 ? 'critical' : 'success'}">
                            ${shadows.totalPatternsDetected} patterns
                        </span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Integrity</span>
                        <span class="metric-value ${shadows.systemIntegrity.score < 0.7 ? 'critical' : 'success'}">
                            ${(shadows.systemIntegrity.score * 100).toFixed(1)}%
                        </span>
                    </div>
                </div>
            `;

            // Add dynamics section for Complete mode
            if (dynamics) {
                html += `
                    <!-- System Dynamics -->
                    <div class="analysis-section">
                        <div class="section-title">âš¡ System Dynamics</div>
                        <div class="metric-row">
                            <span class="metric-label">Pattern</span>
                            <span class="metric-value">${dynamics.feedbackLoops.summary.dominantPattern}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Trajectory</span>
                            <span class="metric-value">${dynamics.attractors.trajectory.type}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Stability</span>
                            <span class="metric-value">${dynamics.attractors.stability.status}</span>
                        </div>
                    </div>

                    <!-- Feedback Loops -->
                    <div class="analysis-section">
                        <div class="section-title">ðŸ”„ Feedback Loops</div>
                        <div class="metric-row">
                            <span class="metric-label">Total Loops</span>
                            <span class="metric-value">${dynamics.feedbackLoops.summary.totalLoops}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Vicious</span>
                            <span class="metric-value critical">${dynamics.feedbackLoops.summary.vicious}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Virtuous</span>
                            <span class="metric-value success">${dynamics.feedbackLoops.summary.virtuous}</span>
                        </div>
                    </div>

                    <!-- Phase Transitions -->
                    <div class="analysis-section">
                        <div class="section-title">ðŸŒŠ Phase Transitions</div>
                        <div class="metric-row">
                            <span class="metric-label">Nearest</span>
                            <span class="metric-value">${dynamics.phaseTransitions.nearestTransition.name}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Proximity</span>
                            <span class="metric-value ${dynamics.phaseTransitions.proximity > 0.7 ? 'warning' : ''}">
                                ${(dynamics.phaseTransitions.proximity * 100).toFixed(0)}%
                            </span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Likelihood</span>
                            <span class="metric-value">${dynamics.phaseTransitions.prediction.likelihood}</span>
                        </div>
                    </div>
                `;
            }

            content.innerHTML = html;
        }

        function updateModeUI(mode) {
            // Update mode buttons
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');

            // Update subtitle
            const subtitles = {
                standard: 'Interactive Organizational Geometry',
                advanced: 'Advanced Mathematical Visualization with Edge Tensions & Vortex Dynamics',
                complete: 'Complete Mathematical Oracle - Full Dynamics & Feedback Analysis',
                minimal: 'Clean Presentation View'
            };
            document.getElementById('pageSubtitle').textContent = subtitles[mode];

            // Show/hide panels
            const controlsPanel = document.getElementById('controlsPanel');
            const analysisPanel = document.getElementById('analysisPanel');
            const legend = document.getElementById('legend');
            const modeSelector = document.querySelector('.mode-selector');

            if (mode === 'standard') {
                controlsPanel.style.display = 'block';
                analysisPanel.classList.remove('visible');
                legend.style.display = 'block';
                modeSelector.style.display = 'block';
            } else if (mode === 'advanced' || mode === 'complete') {
                controlsPanel.style.display = 'none';
                analysisPanel.classList.add('visible');
                legend.style.display = 'block';
                modeSelector.style.display = 'block';
            } else if (mode === 'minimal') {
                controlsPanel.style.display = 'none';
                analysisPanel.classList.remove('visible');
                legend.style.display = 'none';
                modeSelector.style.display = 'none';
            }
        }

        // Parent-child communication (from standard mode)
        window.addEventListener('message', async (event) => {
            const { type, companyId } = event.data;

            if (type === 'LOAD_COMPANY') {
                console.log(`[3D View] ðŸ“¨ Received company load request from parent: ${companyId}`);

                if (currentLoadedCompanyId === companyId) {
                    console.log(`[3D View] â„¹ï¸ Company "${companyId}" is already loaded, skipping duplicate load`);
                    return;
                }

                try {
                    const loading = document.getElementById('loading');
                    if (loading) loading.classList.remove('hidden');

                    if (companyId && window.CompanyLoader) {
                        console.log(`[3D View] ðŸ”„ Loading company: ${companyId}`);
                        const company = await window.CompanyLoader.loadCompany(companyId);

                        if (window.Quannex) {
                            await window.Quannex.initWithCompany(company);
                        }

                        if (window.refreshVisualization) {
                            window.refreshVisualization();
                        }

                        currentLoadedCompanyId = companyId;

                        const state = window.Quannex ? window.Quannex.getState() : null;
                        if (state) {
                            const coherencePercent = (state.globalCoherence * 100).toFixed(1);
                            document.getElementById('statCoherence').textContent = coherencePercent + '%';

                            const status = state.globalCoherence >= 0.7 ? 'Healthy' :
                                         state.globalCoherence >= 0.5 ? 'Moderate' : 'Critical';
                            document.getElementById('statStatus').textContent = status;
                        }

                        if (loading) loading.classList.add('hidden');

                        console.log(`[3D View] âœ… Loaded company from parent: ${company.name}`);
                    } else {
                        console.warn('[3D View] âš ï¸ CompanyLoader not available');
                    }
                } catch (error) {
                    console.error('[3D View] âŒ Failed to load company from parent:', error);
                    const loading = document.getElementById('loading');
                    if (loading) loading.classList.add('hidden');
                }
            }
        });

        // Check sessionStorage for custom data
        async function checkSessionStorage() {
            const selectedCompanyId = sessionStorage.getItem('selectedCompanyId');
            const customDataJson = sessionStorage.getItem('customCompanyData');

            if (selectedCompanyId === 'custom' && customDataJson) {
                try {
                    console.log(`[3D View] ðŸŽ¨ Loading CUSTOM data from orchestrator`);
                    const customData = JSON.parse(customDataJson);

                    const loading = document.getElementById('loading');
                    if (loading) loading.classList.remove('hidden');

                    const company = {
                        id: 'custom',
                        name: customData.name || 'Custom Analysis',
                        description: customData.description || 'User-generated data',
                        kpis: customData.kpis || [],
                        faceConfig: customData.faceConfig || null
                    };

                    let attempts = 0;
                    while (!window.Quannex && attempts < 10) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                        attempts++;
                    }

                    if (window.Quannex) {
                        await window.Quannex.initWithCompany(company);

                        if (window.refreshVisualization) {
                            window.refreshVisualization();
                        }

                        const state = window.Quannex.getState();
                        if (state) {
                            const coherencePercent = (state.globalCoherence * 100).toFixed(1);
                            document.getElementById('statCoherence').textContent = coherencePercent + '%';

                            const status = state.globalCoherence >= 0.7 ? 'Healthy' :
                                         state.globalCoherence >= 0.5 ? 'Moderate' : 'Critical';
                            document.getElementById('statStatus').textContent = status;
                        }

                        const companyButtons = document.querySelectorAll('.control-group button[id^="company"]');
                        if (companyButtons.length > 0) {
                            companyButtons.forEach(btn => btn.style.display = 'none');
                        }
                        const companyLabel = document.querySelector('.control-group .control-label');
                        if (companyLabel && companyLabel.textContent === 'Company') {
                            companyLabel.textContent = 'Custom Analysis';
                        }
                    }

                    currentLoadedCompanyId = 'custom';

                    if (loading) loading.classList.add('hidden');

                    console.log(`[3D View] âœ… Successfully loaded custom data`);
                    return true;
                } catch (error) {
                    console.error('[3D View] âŒ Failed to load custom data:', error);
                }
            } else if (window.self !== window.top && selectedCompanyId) {
                if (selectedCompanyId && !currentLoadedCompanyId) {
                    console.log(`[3D View] ðŸ’¾ Found company ID in sessionStorage: ${selectedCompanyId}`);
                    window.postMessage({ type: 'LOAD_COMPANY', companyId: selectedCompanyId }, '*');
                }
            }
        }

        // Auto-refresh polling
        let lastKnownTimestamp = null;

        function checkForUpdates() {
            const customDataJson = sessionStorage.getItem('customCompanyData');
            if (!customDataJson) return;

            try {
                const customData = JSON.parse(customDataJson);
                const newTimestamp = customData.timestamp;

                if (lastKnownTimestamp && newTimestamp !== lastKnownTimestamp) {
                    console.log('[3D View] ðŸ”„ Detected data update! Reloading...');
                    checkSessionStorage();
                }

                lastKnownTimestamp = newTimestamp;
            } catch (error) {
                console.error('[3D View] âŒ Error checking for updates:', error);
            }
        }

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('[3D View] ðŸ‘€ Tab became visible - checking for updates...');
                checkForUpdates();
            }
        });

        setInterval(checkForUpdates, 2000);

        // Check if in iframe
        if (window.self !== window.top) {
            document.getElementById('pageHeader').classList.add('hidden');
        }

        // Initialize
        setTimeout(checkSessionStorage, 1000);

        // Handle Tuning Inputs
        const tuningInputs = [
            { id: 'rangeAlpha', key: 'ALPHA', display: 'valAlpha' },
            { id: 'rangeBeta', key: 'BETA', display: 'valBeta' },
            { id: 'rangeGamma', key: 'GAMMA', display: 'valGamma' },
            { id: 'rangeDelta', key: 'DELTA', display: 'valDelta' },
            { id: 'rangeKappa', key: 'KAPPA', display: 'valKappa' }
        ];

        tuningInputs.forEach(input => {
            const el = document.getElementById(input.id);
            const display = document.getElementById(input.display);
            
            if (el && display) {
                el.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    display.textContent = val;
                    
                    if (window.Quannex && window.Quannex.updateTuning) {
                        window.Quannex.updateTuning(input.key, val);
                        
                        // Trigger visual refresh
                        if (window.refreshVisualization) {
                            window.refreshVisualization();
                        }
                        
                        // Update stats
                        const state = window.Quannex.getState();
                        const coherencePercent = (state.globalCoherence * 100).toFixed(1);
                        document.getElementById('statCoherence').textContent = coherencePercent + '%';
                    }
                });
            }
        });

        console.log('[3D View] ðŸ“¡ Unified visualization initialized');
        console.log('[3D View] ðŸŽ¨ Mode system ready - Standard/Advanced/Complete/Minimal');
    </script>
</body>
</html>
