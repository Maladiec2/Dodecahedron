<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî∑ Living Dodecahedron - Complete Mathematical Oracle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        .page-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 15px 30px;
            backdrop-filter: blur(20px);
            background: rgba(0, 0, 0, 0.85);
            border-bottom: 1px solid rgba(0, 255, 204, 0.3);
        }

        .page-title {
            font-size: 22px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #00ffcc;
        }

        .page-subtitle {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 3px;
            letter-spacing: 1px;
        }

        .analysis-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 340px;
            max-height: calc(100vh - 100px);
            background: rgba(0, 0, 0, 0.92);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            z-index: 200;
            overflow-y: auto;
        }

        .analysis-section {
            padding: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .analysis-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            color: #00ffcc;
            margin-bottom: 12px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
        }

        .metric-label {
            opacity: 0.7;
        }

        .metric-value {
            color: #00ffcc;
            font-weight: 600;
        }

        .metric-value.critical {
            color: #ff6b6b;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.success {
            color: #00ff66;
        }

        .insight-card {
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 11px;
        }

        .insight-card.warning {
            background: rgba(255, 170, 0, 0.1);
            border-left-color: #ffaa00;
        }

        .insight-card.opportunity {
            background: rgba(0, 255, 102, 0.1);
            border-left-color: #00ff66;
        }

        .insight-card.critical {
            background: rgba(255, 107, 107, 0.15);
            border-left-color: #ff6b6b;
        }

        .insight-title {
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .insight-message {
            opacity: 0.9;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .insight-action {
            opacity: 0.8;
            font-size: 10px;
            font-style: italic;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            flex-direction: column;
            gap: 20px;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            border: 3px solid rgba(0, 255, 204, 0.2);
            border-top: 3px solid #00ffcc;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            letter-spacing: 1px;
        }

        .phase-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 170, 0, 0.15);
            border: 2px solid #ffaa00;
            border-radius: 12px;
            padding: 20px 30px;
            backdrop-filter: blur(10px);
            z-index: 500;
            animation: pulse 2s ease-in-out infinite;
            display: none;
        }

        .phase-warning.visible {
            display: block;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        .phase-warning-title {
            font-size: 18px;
            font-weight: 600;
            color: #ffaa00;
            margin-bottom: 10px;
            text-align: center;
        }

        .phase-warning-message {
            font-size: 14px;
            text-align: center;
            line-height: 1.6;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 204, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 204, 0.5);
        }
    </style>
</head>

<body>
    <div class="page-header">
        <div class="page-title">üî∑ Living Dodecahedron - Complete Mathematical Oracle</div>
        <div class="page-subtitle">Pure Sacred Geometry ‚Ä¢ Advanced Dynamics ‚Ä¢ Feedback Loops ‚Ä¢ Phase Transitions ‚Ä¢
            Attractor Basins</div>
    </div>

    <div id="canvas-container">
        <canvas id="scene"></canvas>
    </div>

    <div class="analysis-panel">
        <div id="analysis-content"></div>
    </div>

    <div id="phase-warning" class="phase-warning">
        <div class="phase-warning-title">‚ö†Ô∏è PHASE TRANSITION IMMINENT</div>
        <div class="phase-warning-message" id="phase-warning-message"></div>
    </div>

    <div id="loading" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Initializing complete mathematical oracle...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        import { SpectralAnalyzer } from './js/advanced/spectral-analyzer.js';
        import { EdgeAnalyzer } from './js/advanced/edge-analyzer.js';
        import { VertexAnalyzer } from './js/advanced/vertex-analyzer.js';
        import { ShadowDetector } from './js/advanced/shadow-detector.js';
        import { DynamicsAnalyzer } from './js/advanced/dynamics-analyzer.js';

        console.log('üöÄ Complete Mathematical Oracle Initializing...');

        const QUANNEX_DATA = {
            name: 'Quannex',
            faces: [
                { id: 1, name: 'Financial Capital', faceEnergy: 0.3930 },
                { id: 2, name: 'Intellectual Capital', faceEnergy: 0.6094 },
                { id: 3, name: 'Human Capital', faceEnergy: 0.1872 },
                { id: 4, name: 'Structural Capital', faceEnergy: 0.3720 },
                { id: 5, name: 'Market Resonance', faceEnergy: 0.0000 },
                { id: 6, name: 'Community & Partners', faceEnergy: 0.4025 },
                { id: 7, name: 'Brand & Reputation', faceEnergy: 0.3132 },
                { id: 8, name: 'Core Operations', faceEnergy: 0.4074 },
                { id: 9, name: 'Regenerative Flow', faceEnergy: 0.6702 },
                { id: 10, name: 'Foundational Values', faceEnergy: 0.6702 },
                { id: 11, name: 'Funding Pipeline', faceEnergy: 0.1925 },
                { id: 12, name: 'Risk & Resilience', faceEnergy: 0.2691 }
            ],
            kpis: [
                { id: 'R1.1', name: 'Bus Factor', value: 1.27 }
            ]
        };

        let scene, camera, renderer, controls;
        let faceMeshes = [];
        let edgeLines = [];
        let vertexSpheres = [];
        let loopLines = []; // NEW: For visualizing feedback loops
        let advancedAnalysis = null;
        let dynamicsAnalysis = null;

        // Analyzers
        const spectral = new SpectralAnalyzer();
        const edgeAnalyzer = new EdgeAnalyzer();
        const vertexAnalyzer = new VertexAnalyzer();
        const shadowDetector = new ShadowDetector();
        const dynamics = new DynamicsAnalyzer();

        async function init() {
            try {
                setupScene();
                runAdvancedAnalysis();
                runDynamicsAnalysis(); // NEW!
                createDodecahedron();
                updateVisualization();
                updateAnalysisPanel();
                checkPhaseTransitionWarning(); // NEW!
                animate();

                document.getElementById('loading').classList.add('hidden');
                console.log('‚úÖ Complete Mathematical Oracle ready!');
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
                document.querySelector('.loading-text').textContent = `Error: ${error.message}`;
            }
        }

        function setupScene() {
            const canvas = document.getElementById('scene');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 15, 50);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 6, 6);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 1.2;
            controls.minDistance = 3;
            controls.maxDistance = 15;
            controls.enablePan = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.6;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xffffff, 0.8);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00ffcc, 0.3);
            pointLight2.position.set(-5, -5, -5);
            scene.add(pointLight2);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function runAdvancedAnalysis() {
            const faceEnergies = QUANNEX_DATA.faces.map(f => f.faceEnergy);

            const spectralAnalysis = spectral.analyze(faceEnergies);
            const edgeAnalysis = edgeAnalyzer.calculateAllEdges(QUANNEX_DATA.faces);
            const vertexAnalysis = vertexAnalyzer.calculateAllVertices(QUANNEX_DATA.faces);
            const shadowAnalysis = shadowDetector.analyze(QUANNEX_DATA.faces, QUANNEX_DATA.kpis);

            advancedAnalysis = {
                spectral: spectralAnalysis,
                edges: edgeAnalysis,
                vertices: vertexAnalysis,
                shadows: shadowAnalysis
            };

            console.log('‚úÖ Advanced analysis complete');
        }

        function runDynamicsAnalysis() {
            dynamicsAnalysis = dynamics.analyzeComplete(
                QUANNEX_DATA.faces,
                advancedAnalysis.edges,
                advancedAnalysis.spectral
            );

            console.log('üî¨ Dynamics analysis complete:', dynamicsAnalysis);
        }

        function createDodecahedron() {
            const radius = 2;
            const geometry = new THREE.DodecahedronGeometry(radius);

            const materials = [];
            for (let i = 0; i < 12; i++) {
                materials.push(new THREE.MeshPhongMaterial({
                    color: 0x00ffcc,
                    emissive: 0x002222,
                    emissiveIntensity: 0.3,
                    shininess: 40,
                    side: THREE.DoubleSide
                }));
            }

            geometry.clearGroups();
            for (let i = 0; i < 12; i++) {
                geometry.addGroup(i * 9, 9, i);
            }

            const dodecahedron = new THREE.Mesh(geometry, materials);
            scene.add(dodecahedron);

            window.dodecahedronMaterials = materials;

            QUANNEX_DATA.faces.forEach((face, i) => {
                if (i < materials.length) {
                    const color = getEnergyColor(face.faceEnergy);
                    materials[i].color = color;
                    materials[i].emissive = color.clone().multiplyScalar(0.3);

                    // Highlight frozen faces
                    const frozenFace = dynamicsAnalysis.inertia.faceInertia.find(f => f.faceId === face.id);
                    if (frozenFace && frozenFace.responsiveness === 'Frozen') {
                        materials[i].emissiveIntensity = 0.8;
                    } else {
                        materials[i].emissiveIntensity = face.faceEnergy < 0.4 ? 0.5 : 0.3;
                    }
                }
            });

            console.log('‚úÖ Dodecahedron created');
        }

        function updateVisualization() {
            updateEdgeLines();
            updateVertexSpheres();
            visualizeFeedbackLoops(); // NEW!
        }

        function updateEdgeLines() {
            edgeLines.forEach(line => scene.remove(line));
            edgeLines = [];

            advancedAnalysis.edges.forEach(edge => {
                const face1Center = getFaceCenter(edge.face1Id - 1);
                const face2Center = getFaceCenter(edge.face2Id - 1);

                if (!face1Center || !face2Center) return;

                const points = [face1Center, face2Center];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);

                const material = new THREE.LineBasicMaterial({
                    color: edge.color,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.5 + (edge.tension * 0.5)
                });

                const line = new THREE.Line(geometry, material);
                scene.add(line);
                edgeLines.push(line);
            });
        }

        function updateVertexSpheres() {
            vertexSpheres.forEach(sphere => scene.remove(sphere));
            vertexSpheres = [];

            advancedAnalysis.vertices.forEach(vertex => {
                const position = getVertexPosition(vertex.faceIds);
                if (!position) return;

                // Smaller, cleaner spheres - size varies slightly with vortex strength
                const baseRadius = 0.06;
                const strengthBonus = vertex.vortexStrength * 0.04;
                const radius = baseRadius + strengthBonus;

                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: vertex.color,
                    emissive: vertex.color,
                    emissiveIntensity: vertex.vortexStrength * 0.6,
                    transparent: true,
                    opacity: 0.75 + (vertex.vortexStrength * 0.2) // Stronger vortices more opaque
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);

                // Pulsing for high-leverage points
                if (vertex.isLeveragePoint) {
                    sphere.userData.isPulsing = true;
                    sphere.userData.pulsePhase = Math.random() * Math.PI * 2;
                }

                scene.add(sphere);
                vertexSpheres.push(sphere);
            });
        }

        function visualizeFeedbackLoops() {
            loopLines.forEach(line => scene.remove(line));
            loopLines = [];

            // Visualize top 3 critical feedback loops
            const criticalLoops = dynamicsAnalysis.feedbackLoops.summary.criticalLoops || [];

            criticalLoops.forEach((loop, index) => {
                const points = [];
                loop.cycle.forEach(faceId => {
                    const center = getFaceCenter(faceId - 1);
                    if (center) points.push(center);
                });

                // Close the loop
                if (points.length > 0) {
                    points.push(points[0]);
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);

                // Color based on loop type
                let color;
                if (loop.direction.includes('Vicious')) {
                    color = 0xff6b6b; // Red for vicious
                } else if (loop.direction.includes('Virtuous')) {
                    color = 0x00ff66; // Green for virtuous
                } else {
                    color = 0xffaa00; // Yellow for dampening
                }

                const material = new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.4
                });

                const line = new THREE.Line(geometry, material);
                line.userData.isLoop = true;
                line.userData.loopIndex = index;
                scene.add(line);
                loopLines.push(line);
            });

            console.log(`‚úÖ Visualized ${loopLines.length} critical feedback loops`);
        }

        function checkPhaseTransitionWarning() {
            const transitions = dynamicsAnalysis.phaseTransitions;

            if (transitions.isImminent) {
                const warning = document.getElementById('phase-warning');
                const message = document.getElementById('phase-warning-message');

                message.textContent = `${transitions.nearestTransition.name} transition detected! ` +
                    `${transitions.prediction.message}`;

                warning.classList.add('visible');

                // Hide after 10 seconds
                setTimeout(() => {
                    warning.classList.remove('visible');
                }, 10000);
            }
        }

        function updateAnalysisPanel() {
            const content = document.getElementById('analysis-content');

            const edgeStats = edgeAnalyzer.getTensionStats(advancedAnalysis.edges);
            const vertexStats = vertexAnalyzer.getVortexStats(advancedAnalysis.vertices);

            content.innerHTML = `
                <!-- System State -->
                <div class="analysis-section">
                    <div class="section-title">üåä System Dynamics</div>
                    <div class="metric-row">
                        <span class="metric-label">Pattern</span>
                        <span class="metric-value">${dynamicsAnalysis.summary.systemState.dynamicPattern.substring(0, 25)}...</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Trajectory</span>
                        <span class="metric-value ${dynamicsAnalysis.attractors.trajectory.type.includes('Descending') ? 'critical' : 'success'}">
                            ${dynamicsAnalysis.attractors.trajectory.type}
                        </span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Stability</span>
                        <span class="metric-value">${dynamicsAnalysis.attractors.stability.status}</span>
                    </div>
                </div>

                <!-- Feedback Loops -->
                <div class="analysis-section">
                    <div class="section-title">üîÑ Feedback Loops</div>
                    <div class="metric-row">
                        <span class="metric-label">Total Detected</span>
                        <span class="metric-value">${dynamicsAnalysis.feedbackLoops.summary.totalLoops}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Vicious Cycles</span>
                        <span class="metric-value ${dynamicsAnalysis.feedbackLoops.summary.vicious > 0 ? 'critical' : 'success'}">
                            ${dynamicsAnalysis.feedbackLoops.summary.vicious}
                        </span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Virtuous Cycles</span>
                        <span class="metric-value ${dynamicsAnalysis.feedbackLoops.summary.virtuous > 0 ? 'success' : ''}">
                            ${dynamicsAnalysis.feedbackLoops.summary.virtuous}
                        </span>
                    </div>
                </div>

                <!-- Phase Transitions -->
                <div class="analysis-section">
                    <div class="section-title">üìà Phase Transitions</div>
                    <div class="metric-row">
                        <span class="metric-label">Nearest</span>
                        <span class="metric-value">${dynamicsAnalysis.phaseTransitions.nearestTransition.name}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Proximity</span>
                        <span class="metric-value ${dynamicsAnalysis.phaseTransitions.proximity > 0.7 ? 'warning' : ''}">
                            ${(dynamicsAnalysis.phaseTransitions.proximity * 100).toFixed(0)}%
                        </span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Likelihood</span>
                        <span class="metric-value ${dynamicsAnalysis.phaseTransitions.prediction.likelihood === 'VERY HIGH' ? 'critical' : ''}">
                            ${dynamicsAnalysis.phaseTransitions.prediction.likelihood}
                        </span>
                    </div>
                </div>

                <!-- Inertia -->
                <div class="analysis-section">
                    <div class="section-title">‚è≥ System Inertia</div>
                    <div class="metric-row">
                        <span class="metric-label">Frozen Faces</span>
                        <span class="metric-value ${dynamicsAnalysis.inertia.summary.frozenFaces > 3 ? 'critical' : ''}">
                            ${dynamicsAnalysis.inertia.summary.frozenFaces}
                        </span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Flexibility</span>
                        <span class="metric-value">${dynamicsAnalysis.inertia.summary.systemFlexibility.status}</span>
                    </div>
                </div>

                <!-- Spectral -->
                <div class="analysis-section">
                    <div class="section-title">üéµ Spectral Mode</div>
                    <div class="metric-row">
                        <span class="metric-label">Eigenvalue Œª</span>
                        <span class="metric-value">${advancedAnalysis.spectral.dominantMode.eigenvalue.toFixed(3)}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Dissonance</span>
                        <span class="metric-value ${advancedAnalysis.spectral.diagnostics.dissonanceIndex.percentage > 20 ? 'critical' : 'success'}">
                            ${advancedAnalysis.spectral.diagnostics.dissonanceIndex.percentage.toFixed(1)}%
                        </span>
                    </div>
                </div>

                <!-- Critical Insights -->
                ${dynamicsAnalysis.summary.criticalInsights.length > 0 ? `
                    <div class="analysis-section">
                        <div class="section-title">‚ö° Critical Insights</div>
                        ${dynamicsAnalysis.summary.criticalInsights.map(insight => `
                            <div class="insight-card ${insight.type.toLowerCase()}">
                                <div class="insight-title">${insight.type}: ${insight.category}</div>
                                <div class="insight-message">${insight.message}</div>
                                <div class="insight-action">‚Üí ${insight.action}</div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }

        function getFaceCenter(faceIndex) {
            const phi = (1 + Math.sqrt(5)) / 2;
            const radius = 2;

            const centers = [
                new THREE.Vector3(0, phi, 1).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, phi, -1).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, -phi, 1).normalize().multiplyScalar(radius),
                new THREE.Vector3(0, -phi, -1).normalize().multiplyScalar(radius),
                new THREE.Vector3(1, 0, phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1, 0, phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(1, 0, -phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(-1, 0, -phi).normalize().multiplyScalar(radius),
                new THREE.Vector3(phi, 1, 0).normalize().multiplyScalar(radius),
                new THREE.Vector3(phi, -1, 0).normalize().multiplyScalar(radius),
                new THREE.Vector3(-phi, 1, 0).normalize().multiplyScalar(radius),
                new THREE.Vector3(-phi, -1, 0).normalize().multiplyScalar(radius)
            ];

            return centers[faceIndex];
        }

        // Define the exact 20 geometric vertices of the dodecahedron
        function getDodecahedronVertices() {
            const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
            const radius = 2; // Match face center radius

            // 20 vertices of a dodecahedron in standard orientation
            // Normalized and scaled to radius
            const vertices = [
                // 8 vertices at cube positions
                new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(radius),      // 0
                new THREE.Vector3(1, 1, -1).normalize().multiplyScalar(radius),     // 1
                new THREE.Vector3(1, -1, 1).normalize().multiplyScalar(radius),     // 2
                new THREE.Vector3(1, -1, -1).normalize().multiplyScalar(radius),    // 3
                new THREE.Vector3(-1, 1, 1).normalize().multiplyScalar(radius),     // 4
                new THREE.Vector3(-1, 1, -1).normalize().multiplyScalar(radius),    // 5
                new THREE.Vector3(-1, -1, 1).normalize().multiplyScalar(radius),    // 6
                new THREE.Vector3(-1, -1, -1).normalize().multiplyScalar(radius),   // 7
                // 12 vertices at rectangular positions (golden ratio based)
                new THREE.Vector3(0, phi, 1 / phi).normalize().multiplyScalar(radius),      // 8
                new THREE.Vector3(0, phi, -1 / phi).normalize().multiplyScalar(radius),     // 9
                new THREE.Vector3(0, -phi, 1 / phi).normalize().multiplyScalar(radius),     // 10
                new THREE.Vector3(0, -phi, -1 / phi).normalize().multiplyScalar(radius),    // 11
                new THREE.Vector3(1 / phi, 0, phi).normalize().multiplyScalar(radius),      // 12
                new THREE.Vector3(1 / phi, 0, -phi).normalize().multiplyScalar(radius),     // 13
                new THREE.Vector3(-1 / phi, 0, phi).normalize().multiplyScalar(radius),     // 14
                new THREE.Vector3(-1 / phi, 0, -phi).normalize().multiplyScalar(radius),    // 15
                new THREE.Vector3(phi, 1 / phi, 0).normalize().multiplyScalar(radius),      // 16
                new THREE.Vector3(phi, -1 / phi, 0).normalize().multiplyScalar(radius),     // 17
                new THREE.Vector3(-phi, 1 / phi, 0).normalize().multiplyScalar(radius),     // 18
                new THREE.Vector3(-phi, -1 / phi, 0).normalize().multiplyScalar(radius)     // 19
            ];

            return vertices;
        }

        // Map analytical vertex ID (1-20) to geometric vertex index (0-19)
        // This is based on which 3 faces meet at each vertex
        function getGeometricVertexIndex(vertexId) {
            // Mapping from VertexAnalyzer vertex IDs to geometric vertex positions
            // This mapping is determined by the dodecahedron topology
            const mapping = {
                1: 8,   // Faces [1, 2, 6] -> top front
                2: 4,   // Faces [1, 5, 6] -> top left front
                3: 12,  // Faces [1, 5, 8] -> front bottom left
                4: 0,   // Faces [1, 8, 9] -> top right front
                5: 16,  // Faces [1, 2, 9] -> right front top
                6: 9,   // Faces [2, 3, 6] -> top front right
                7: 5,   // Faces [2, 3, 10] -> top left back
                8: 1,   // Faces [2, 9, 10] -> top right back
                9: 18,  // Faces [3, 4, 6] -> left front
                10: 15, // Faces [3, 4, 11] -> left back top
                11: 19, // Faces [3, 10, 11] -> left back
                12: 14, // Faces [4, 5, 6] -> left front bottom
                13: 13, // Faces [4, 5, 7] -> front
                14: 7,  // Faces [4, 7, 11] -> back bottom
                15: 2,  // Faces [5, 7, 8] -> right front bottom
                16: 6,  // Faces [5, 8, 10] -> bottom
                17: 3,  // Faces [7, 8, 12] -> right bottom
                18: 10, // Faces [8, 9, 12] -> bottom front
                19: 17, // Faces [9, 10, 12] -> right back
                20: 11  // Faces [10, 11, 12] -> back bottom
            };

            return mapping[vertexId] !== undefined ? mapping[vertexId] : 0;
        }

        function getVertexPosition(faceIds) {
            // Find which vertex this is by matching face IDs
            const vertex = advancedAnalysis.vertices.find(v =>
                v.faceIds.length === faceIds.length &&
                v.faceIds.every(id => faceIds.includes(id))
            );

            if (!vertex) {
                console.warn('Vertex not found for faces:', faceIds);
                return null;
            }

            const vertices = getDodecahedronVertices();
            const geometricIndex = getGeometricVertexIndex(vertex.vertexId);

            return vertices[geometricIndex];
        }

        function getEnergyColor(energy) {
            if (energy >= 0.7) {
                return new THREE.Color().lerpColors(
                    new THREE.Color(0x00ff88),
                    new THREE.Color(0x00ffcc),
                    (energy - 0.7) / 0.3
                );
            } else if (energy >= 0.4) {
                return new THREE.Color().lerpColors(
                    new THREE.Color(0xff6600),
                    new THREE.Color(0xffcc00),
                    (energy - 0.4) / 0.3
                );
            } else {
                return new THREE.Color().lerpColors(
                    new THREE.Color(0x882222),
                    new THREE.Color(0xff6666),
                    Math.max(energy, 0.05) / 0.4
                );
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Pulse leverage points
            vertexSpheres.forEach(sphere => {
                if (sphere.userData.isPulsing) {
                    const phase = sphere.userData.pulsePhase;
                    const scale = 1 + Math.sin(time * 2 + phase) * 0.4;
                    sphere.scale.setScalar(scale);
                }
            });

            // Pulse feedback loop lines
            loopLines.forEach(line => {
                const phase = line.userData.loopIndex * 0.5;
                const opacity = 0.3 + Math.sin(time * 1.5 + phase) * 0.2;
                line.material.opacity = opacity;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>