<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧬 Organizational DNA - 6 Double Helix Spirals</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: radial-gradient(circle at 50% 50%, #0a0a1a 0%, #000000 100%);
            color: #00ffcc;
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: default;
            transition: cursor 0.2s ease;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .ui-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 20px;
            backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, 0.85);
            border-bottom: 2px solid #00ffcc;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(90deg, #00ffcc, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px #00ffcc;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            background: rgba(0, 255, 204, 0.1);
            color: #00ffcc;
            border: 1px solid #00ffcc;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 20px #00ffcc;
            transform: translateY(-2px);
        }

        .btn.active {
            background: #00ffcc;
            color: #000;
        }

        .legend {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            border-radius: 8px;
            padding: 15px;
            max-width: 320px;
            font-size: 11px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }

        .legend-title {
            color: #00ffcc;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffcc;
        }

        .legend-section {
            margin-bottom: 15px;
        }

        .legend-section-title {
            color: #ffff00;
            font-size: 11px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 0, 0.3);
            padding-bottom: 3px;
        }

        .helix-item {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 255, 204, 0.05);
            border-radius: 4px;
            border-left: 3px solid;
        }

        .helix-name {
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .helix-faces {
            font-size: 9px;
            color: #aaa;
            line-height: 1.4;
        }

        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            font-size: 11px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }

        .info-title {
            color: #00ffcc;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 13px;
            text-shadow: 0 0 10px #00ffcc;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(0, 255, 204, 0.2);
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #00ffcc;
            font-weight: bold;
        }

        .diagnostic-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ffcc;
            border-radius: 12px;
            padding: 25px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            font-size: 12px;
            box-shadow: 0 0 40px rgba(0, 255, 204, 0.6);
            z-index: 200;
            display: none;
        }

        .diagnostic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #00ffcc;
        }

        .diagnostic-title {
            font-size: 20px;
            font-weight: bold;
            color: #00ffcc;
            text-shadow: 0 0 15px #00ffcc;
        }

        .close-btn {
            cursor: pointer;
            font-size: 24px;
            color: #00ffcc;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            color: #ff0066;
            transform: rotate(90deg);
        }

        .breath-ratio-display {
            background: rgba(0, 255, 204, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .breath-ratio-value {
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
        }

        .breath-status {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .breath-status.balanced {
            background: rgba(0, 255, 102, 0.2);
            color: #00ff66;
        }

        .breath-status.imbalanced {
            background: rgba(255, 102, 102, 0.2);
            color: #ff6666;
        }

        .strand-info {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-bottom: 20px;
        }

        .strand-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid;
        }

        .strand-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .strand-name {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .energy-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .energy-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .tension-section {
            margin-top: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: #ffff00;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 0, 0.3);
            padding-bottom: 5px;
        }

        .octave-tension {
            background: rgba(255, 255, 255, 0.03);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid;
        }

        .octave-header {
            font-weight: bold;
            margin-bottom: 6px;
        }

        .kpi-detail {
            font-size: 11px;
            margin-left: 15px;
            margin-top: 4px;
            color: #aaa;
        }

        .action-item {
            background: rgba(0, 255, 102, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #00ff66;
        }

        .action-number {
            display: inline-block;
            background: #00ff66;
            color: #000;
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            border-radius: 50%;
            margin-right: 8px;
            font-weight: bold;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-size: 20px;
            text-align: center;
            text-shadow: 0 0 30px #00ffcc;
            z-index: 1000;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 255, 204, 0.3);
            border-top: 4px solid #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 255, 204, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 204, 0.5);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui-container">
        <div class="header">
            <div>
                <div class="title">🧬 ORGANIZATIONAL DNA</div>
                <div class="subtitle">6 Double Helix Spirals × 12 Octaves | Golden Ratio Expansion: φ = 1.618...</div>
            </div>
            <div class="controls">
                <button class="btn" id="resetCameraBtn">Reset Camera</button>
                <button class="btn active" id="pausePlayBtn">Pause</button>
                <button class="btn" id="toggleLabelsBtn">Hide Labels</button>
                <button class="btn" id="toggleRungsBtn">Toggle DNA Rungs</button>
                <button class="btn" id="toggleGhostBtn">Toggle Future Octaves</button>
            </div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-title">🧬 DNA Double Helices</div>
        
        <div class="legend-section">
            <div class="legend-section-title">6 Harmonic Pairs</div>
            
            <div class="helix-item" style="border-color: #ff6b6b;">
                <div class="helix-name" style="color: #ff6b6b;">Helix 1: Resource Flow</div>
                <div class="helix-faces">
                    ↗️ F11: Funding Pipeline (Projection)<br>
                    ↙️ F1: Financial Capital (Reception)
                </div>
            </div>

            <div class="helix-item" style="border-color: #4ecdc4;">
                <div class="helix-name" style="color: #4ecdc4;">Helix 2: Substance & Story</div>
                <div class="helix-faces">
                    ↗️ F7: Brand & Reputation (Projection)<br>
                    ↙️ F2: Intellectual Capital (Reception)
                </div>
            </div>

            <div class="helix-item" style="border-color: #ffe66d;">
                <div class="helix-name" style="color: #ffe66d;">Helix 3: Being & Doing</div>
                <div class="helix-faces">
                    ↗️ F8: Core Operations (Projection)<br>
                    ↙️ F3: Human Capital (Reception)
                </div>
            </div>

            <div class="helix-item" style="border-color: #95e1d3;">
                <div class="helix-name" style="color: #95e1d3;">Helix 4: Form & Integrity</div>
                <div class="helix-faces">
                    ↗️ F4: Structural Capital (Projection)<br>
                    ↙️ F9: Regenerative Flow (Reception)
                </div>
            </div>

            <div class="helix-item" style="border-color: #f38181;">
                <div class="helix-name" style="color: #f38181;">Helix 5: Perception & Truth</div>
                <div class="helix-faces">
                    ↗️ F5: Market Resonance (Projection)<br>
                    ↙️ F10: Foundational Values (Reception)
                </div>
            </div>

            <div class="helix-item" style="border-color: #aa96da;">
                <div class="helix-name" style="color: #aa96da;">Helix 6: Network & Fortress</div>
                <div class="helix-faces">
                    ↗️ F6: Community & Partners (Projection)<br>
                    ↙️ F12: Risk & Resilience (Reception)
                </div>
            </div>
        </div>

        <div class="legend-section">
            <div class="legend-section-title">Octave Evolution</div>
            <div style="font-size: 9px; line-height: 1.5; color: #aaa;">
                <strong style="color: #ff3333;">O1: Survival</strong> → Dense, Blazing<br>
                <strong style="color: #ff9900;">O2: Structure</strong><br>
                <strong style="color: #ffff00;">O3: Relationships</strong><br>
                <strong style="color: #00ff66;">O4: Creativity</strong><br>
                <strong style="color: #00ffcc;">O5: Expression</strong><br>
                <strong style="color: #00ccff;">O6: Vision</strong><br>
                <strong style="color: #aa00ff;">O7: Radiance</strong> → Ethereal<br>
                <strong style="color: #6666ff;">O8-O12</strong> → Ghost Spirals
            </div>
        </div>

        <div class="legend-section">
            <div class="legend-section-title">💡 Interaction</div>
            <div style="font-size: 9px; line-height: 1.5; color: #00ffcc;">
                <strong>🖱️ Click on any double helix</strong> to:<br>
                • See breath ratio analysis<br>
                • Identify root tensions<br>
                • Get actionable recommendations<br>
                • Understand projection/reception balance
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-title">📊 DNA Structure</div>
        <div class="info-item">
            <span class="info-label">Double Helices:</span>
            <span class="info-value">6</span>
        </div>
        <div class="info-item">
            <span class="info-label">Total Strands:</span>
            <span class="info-value">12</span>
        </div>
        <div class="info-item">
            <span class="info-label">Real Octaves:</span>
            <span class="info-value">7</span>
        </div>
        <div class="info-item">
            <span class="info-label">Future Octaves:</span>
            <span class="info-value">5 (∞)</span>
        </div>
        <div class="info-item">
            <span class="info-label">DNA Rungs:</span>
            <span class="info-value">72</span>
        </div>
        <div class="info-item">
            <span class="info-label">φ (Golden):</span>
            <span class="info-value">1.618...</span>
        </div>
        <div class="info-item">
            <span class="info-label">Balanced Axes:</span>
            <span class="info-value" id="infoBalanced">—</span>
        </div>
        <div class="info-item">
            <span class="info-label">FPS:</span>
            <span class="info-value" id="infoFPS">—</span>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>Sequencing Organizational DNA...</div>
    </div>

    <!-- Diagnostic Panel -->
    <div class="diagnostic-panel" id="diagnosticPanel">
        <div class="diagnostic-header">
            <div class="diagnostic-title" id="diagnosticTitle">🧬 Helix Analysis</div>
            <div class="close-btn" id="closeDiagnostic">✕</div>
        </div>
        <div id="diagnosticContent">
            <!-- Dynamic content will be inserted here -->
        </div>
    </div>

<script src="https://unpkg.com/three@0.128.0/build/three.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const API_BASE = 'http://localhost:3001/api';

        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 40, 100);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 25, 30);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Enhanced lighting for DNA glow
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        const pointLight1 = new THREE.PointLight(0x00ffcc, 1.2);
        const pointLight2 = new THREE.PointLight(0xff00ff, 0.8);
        const pointLight3 = new THREE.PointLight(0xffff00, 0.6);
        const topLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight1.position.set(20, 15, 20);
        pointLight2.position.set(-20, 10, -20);
        pointLight3.position.set(0, 5, 15);
        topLight.position.set(0, 35, 0);
        scene.add(ambientLight, pointLight1, pointLight2, pointLight3, topLight);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;
        controls.target.set(0, 10, 0);

        // Configuration
        const CONFIG = {
            helixSpacing: 12,              // Distance between double helix centers
            helixHeight: 22,               // Total height
            helixTurns: 4,                 // Turns per helix
            strandRadius: 0.8,             // Distance between the two strands of a double helix
            tubeRadius: 0.18,              // Thickness of strands
            rungRadius: 0.08,              // Thickness of connecting rungs
            segments: 150,                 // Smoothness
            goldenRatio: 1.618033988749895,
            maxOctaves: 12,
            expansionPower: 0.8,           // Dramatic expansion
            baseRadiusStart: 0.25,         // Very tight start
            opacityExponent: 1.3           // Opacity curve
        };

        // State
        let dnaGroup = null;
        let rungsGroup = null;
        let allFacesData = [];
        let breathAnalysisData = null;
        let helixBreathRatios = new Map(); // Store breath ratios for each helix
        let animationRunning = true;
        let showLabels = true;
        let showRungs = true;
        let showGhostOctaves = true;
        let selectedHelix = null;
        let highlightedMeshes = [];
        let breathingMeshes = []; // Meshes that pulse based on breath

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Animation time for breathing effects
        let breathTime = 0;

        // DNA Double Helix Pairs (Harmonic Breath Axes)
        const DNA_HELICES = [
            { 
                id: 1, 
                name: 'Resource Flow',
                strand1: { faceId: 11, name: 'Funding Pipeline', role: 'Projection' },
                strand2: { faceId: 1, name: 'Financial Capital', role: 'Reception' },
                color: 0xff6b6b,
                position: { angle: 0 } // Top position in hexagon
            },
            { 
                id: 2, 
                name: 'Substance & Story',
                strand1: { faceId: 7, name: 'Brand & Reputation', role: 'Projection' },
                strand2: { faceId: 2, name: 'Intellectual Capital', role: 'Reception' },
                color: 0x4ecdc4,
                position: { angle: Math.PI / 3 } // 60° clockwise
            },
            { 
                id: 3, 
                name: 'Being & Doing',
                strand1: { faceId: 8, name: 'Core Operations', role: 'Projection' },
                strand2: { faceId: 3, name: 'Human Capital', role: 'Reception' },
                color: 0xffe66d,
                position: { angle: 2 * Math.PI / 3 } // 120°
            },
            { 
                id: 4, 
                name: 'Form & Integrity',
                strand1: { faceId: 4, name: 'Structural Capital', role: 'Projection' },
                strand2: { faceId: 9, name: 'Regenerative Flow', role: 'Reception' },
                color: 0x95e1d3,
                position: { angle: Math.PI } // 180° (bottom)
            },
            { 
                id: 5, 
                name: 'Perception & Truth',
                strand1: { faceId: 5, name: 'Market Resonance', role: 'Projection' },
                strand2: { faceId: 10, name: 'Foundational Values', role: 'Reception' },
                color: 0xf38181,
                position: { angle: 4 * Math.PI / 3 } // 240°
            },
            { 
                id: 6, 
                name: 'Network & Fortress',
                strand1: { faceId: 6, name: 'Community & Partners', role: 'Projection' },
                strand2: { faceId: 12, name: 'Risk & Resilience', role: 'Reception' },
                color: 0xaa96da,
                position: { angle: 5 * Math.PI / 3 } // 300°
            }
        ];

        // Face-specific colors
        const FACE_COLORS = {
            1: 0x9b59b6, 2: 0xe74c3c, 3: 0xf39c12, 4: 0x2ecc71,
            5: 0x3498db, 6: 0x1abc9c, 7: 0xe67e22, 8: 0x95a5a6,
            9: 0x27ae60, 10: 0xc0392b, 11: 0x8e44ad, 12: 0x34495e
        };

        /**
         * Calculate Fibonacci expansion radius for octave
         */
        function getFibonacciRadius(octaveId) {
            const expansion = Math.pow(CONFIG.goldenRatio, (octaveId - 1) * CONFIG.expansionPower);
            return CONFIG.baseRadiusStart * expansion;
        }

        /**
         * Get breath-adjusted visual properties for a helix
         */
        function getBreathAdjustedProperties(helixId, breathRatio) {
            const imbalance = Math.abs(1 - breathRatio);
            
            let opacityMultiplier = 1.0;
            let colorShift = 0;
            let pulseFrequency = 1.0;
            let pulseAmplitude = 0.1;
            
            if (breathRatio >= 0.8 && breathRatio <= 1.2) {
                // BALANCED - Healthy, bright, steady
                opacityMultiplier = 1.0;
                colorShift = 0;
                pulseFrequency = 0.8;
                pulseAmplitude = 0.08;
            } else if (imbalance <= 0.4) {
                // MILD IMBALANCE
                opacityMultiplier = 0.85;
                colorShift = 0.15;
                pulseFrequency = 1.2;
                pulseAmplitude = 0.15;
            } else if (imbalance <= 0.8) {
                // MODERATE IMBALANCE
                opacityMultiplier = 0.65;
                colorShift = 0.35;
                pulseFrequency = 1.8;
                pulseAmplitude = 0.25;
            } else {
                // SEVERE IMBALANCE
                opacityMultiplier = 0.45;
                colorShift = 0.6;
                pulseFrequency = 2.5;
                pulseAmplitude = 0.35;
            }
            
            return {
                opacityMultiplier,
                colorShift,
                pulseFrequency,
                pulseAmplitude,
                isBalanced: imbalance < 0.2
            };
        }

        /**
         * Shift color toward red/orange based on imbalance
         */
        function shiftColorToWarning(originalColor, shiftAmount) {
            if (shiftAmount === 0) return originalColor;
            
            const r = (originalColor >> 16) & 255;
            const g = (originalColor >> 8) & 255;
            const b = originalColor & 255;
            
            // Shift toward red/orange (warning)
            const targetR = 255;
            const targetG = Math.max(0, 100 - shiftAmount * 50);
            const targetB = 0;
            
            const newR = Math.round(r + (targetR - r) * shiftAmount);
            const newG = Math.round(g + (targetG - g) * shiftAmount);
            const newB = Math.round(b + (targetB - b) * shiftAmount);
            
            return (newR << 16) | (newG << 8) | newB;
        }

        /**
         * Calculate opacity with dramatic gradient
         */
        function getOctaveOpacity(octaveId, coherence = 0.5, breathMultiplier = 1.0) {
            if (octaveId <= 7) {
                // O1 = SOLID (0.9-1.0), O7 = Ethereal (0.4-0.5)
                const baseOpacity = Math.pow(1 - ((octaveId - 1) / 7), CONFIG.opacityExponent);
                const coherenceBoost = 0.6 + (0.4 * coherence);
                const finalOpacity = baseOpacity * coherenceBoost;
                const minOpacity = Math.max(0.35, 1 - (octaveId - 1) * 0.09);
                const octaveOpacity = Math.max(minOpacity, Math.min(1.0, finalOpacity));
                
                // Apply breath ratio modifier
                return octaveOpacity * breathMultiplier;
            } else {
                // Ghost spirals (O8-O12)
                const beyondProgress = (octaveId - 7) / (CONFIG.maxOctaves - 7);
                const ghostOpacity = Math.max(0.05, 0.3 * (1 - Math.pow(beyondProgress, 1.2)));
                return ghostOpacity * breathMultiplier;
            }
        }

        /**
         * Calculate emissive intensity
         */
        function getEmissiveIntensity(octaveId, coherence = 0.5) {
            if (octaveId <= 7) {
                const octaveProgress = (octaveId - 1) / 6;
                const baseIntensity = 1.2 - (octaveProgress * 0.7); // 1.2 → 0.5
                return baseIntensity * (0.5 + coherence * 0.5);
            } else {
                return 0.05 + (getOctaveOpacity(octaveId, coherence) * 0.3);
            }
        }

        /**
         * Get position for a double helix in hexagonal arrangement
         */
        function getHelixCenterPosition(helixId) {
            const helix = DNA_HELICES[helixId - 1];
            const x = Math.cos(helix.position.angle) * CONFIG.helixSpacing;
            const z = Math.sin(helix.position.angle) * CONFIG.helixSpacing;
            return { x, z };
        }

        /**
         * Load all faces data and breath analysis
         */
        async function loadAllFaces() {
            const promises = [];
            for (let faceId = 1; faceId <= 12; faceId++) {
                promises.push(
                    fetch(`${API_BASE}/octave-helix/${faceId}`)
                        .then(res => res.json())
                        .then(data => data.success ? data.data : null)
                        .catch(err => {
                            console.error(`Failed to load face ${faceId}:`, err);
                            return null;
                        })
                );
            }
            
            allFacesData = await Promise.all(promises);
            console.log('✅ Loaded data for all 12 faces');
            
            // Load breath analysis
            breathAnalysisData = await fetchBreathAnalysis();
            if (breathAnalysisData) {
                calculateHelixBreathRatios();
                console.log('✅ Breath analysis loaded and ratios calculated');
            }
        }

        /**
         * Calculate breath ratios for each helix
         */
        function calculateHelixBreathRatios() {
            DNA_HELICES.forEach(helix => {
                const face1Data = allFacesData[helix.strand1.faceId - 1];
                const face2Data = allFacesData[helix.strand2.faceId - 1];
                
                if (!face1Data || !face2Data) return;
                
                // Get average coherence for each face
                const getAvgCoherence = (faceData) => {
                    if (!faceData.ballHelix?.coherenceData?.length) return 0.5;
                    const sum = faceData.ballHelix.coherenceData.reduce((s, d) => s + d.value, 0);
                    return sum / faceData.ballHelix.coherenceData.length;
                };
                
                const energy1 = getAvgCoherence(face1Data);
                const energy2 = getAvgCoherence(face2Data);
                
                const breathRatio = energy2 > 0 ? energy1 / energy2 : 1;
                
                helixBreathRatios.set(helix.id, {
                    ratio: breathRatio,
                    energy1,
                    energy2,
                    isBalanced: breathRatio >= 0.8 && breathRatio <= 1.2,
                    imbalanceSeverity: Math.abs(1 - breathRatio)
                });
            });
        }

        /**
         * Create a DNA strand curve with Fibonacci expansion
         * strandOffset: +1 or -1 to position on either side of the helix axis
         */
        function createDNAStrand(helixCenter, faceId, ballHelix, strandOffset) {
            const curves = [];
            
            if (!ballHelix || !ballHelix.points || ballHelix.points.length === 0) {
                return null;
            }

            const pointsPerOctave = Math.floor(ballHelix.points.length / 7);
            
            for (let octaveId = 1; octaveId <= CONFIG.maxOctaves; octaveId++) {
                if (octaveId > 7 && !showGhostOctaves) continue;
                
                const points = [];
                const fibRadius = getFibonacciRadius(octaveId);
                
                const heightMultiplier = octaveId <= 7 ? 1 : 1.15;
                const effectiveHeight = CONFIG.helixHeight * heightMultiplier;
                const yStart = ((octaveId - 1) / 7) * effectiveHeight;
                const yEnd = (octaveId / 7) * effectiveHeight;
                
                const segmentPoints = octaveId <= 7 ? pointsPerOctave : 25;
                
                for (let i = 0; i <= segmentPoints; i++) {
                    const t = i / segmentPoints;
                    const globalT = ((octaveId - 1) + t) / 7;
                    
                    // DNA double helix: two strands rotate 180° out of phase
                    const angle = 2 * Math.PI * CONFIG.helixTurns * globalT + (strandOffset > 0 ? 0 : Math.PI);
                    const y = yStart + (yEnd - yStart) * t;
                    
                    // Position: helix center + spiral offset
                    const spiralR = CONFIG.strandRadius * fibRadius;
                    const x = helixCenter.x + spiralR * Math.cos(angle);
                    const z = helixCenter.z + spiralR * Math.sin(angle);
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                if (points.length > 1) {
                    const curve = new THREE.CatmullRomCurve3(points);
                    
                    let coherence = 0.5;
                    if (octaveId <= 7 && ballHelix.coherenceData) {
                        const octaveData = ballHelix.coherenceData.filter(d => d.octave === octaveId);
                        if (octaveData.length > 0) {
                            coherence = octaveData.reduce((sum, d) => sum + d.value, 0) / octaveData.length;
                        }
                    }
                    
                    curves.push({
                        curve,
                        octaveId,
                        opacity: getOctaveOpacity(octaveId, coherence),
                        emissive: getEmissiveIntensity(octaveId, coherence),
                        fibRadius,
                        coherence
                    });
                }
            }

            return curves;
        }

        /**
         * Render all 6 DNA double helices
         */
        function renderDNAHelices() {
            if (dnaGroup) {
                scene.remove(dnaGroup);
            }

            dnaGroup = new THREE.Group();
            breathingMeshes = []; // Clear breathing meshes array

            DNA_HELICES.forEach(helix => {
                const helixCenter = getHelixCenterPosition(helix.id);
                
                // Get data for both strands
                const strand1Data = allFacesData[helix.strand1.faceId - 1];
                const strand2Data = allFacesData[helix.strand2.faceId - 1];
                
                if (!strand1Data || !strand2Data) return;

                // Get breath ratio for this helix
                const breathData = helixBreathRatios.get(helix.id) || { ratio: 1.0 };
                
                // Create first strand (Projection - clockwise)
                const strand1Curves = createDNAStrand(helixCenter, helix.strand1.faceId, strand1Data.ballHelix, 1);
                if (strand1Curves) {
                    renderStrand(strand1Curves, helix.strand1.faceId, helix.color, true, helix.id, breathData.ratio);
                }

                // Create second strand (Reception - counter-clockwise, 180° offset)
                const strand2Curves = createDNAStrand(helixCenter, helix.strand2.faceId, strand2Data.ballHelix, -1);
                if (strand2Curves) {
                    renderStrand(strand2Curves, helix.strand2.faceId, helix.color, false, helix.id, breathData.ratio);
                }

                // Add helix label at top
                if (showLabels) {
                    addLabel(
                        helix.name,
                        helixCenter.x,
                        CONFIG.helixHeight + 1,
                        helixCenter.z,
                        helix.color,
                        1.0
                    );
                }
            });

            // Add octave markers
            addOctaveMarkers();

            scene.add(dnaGroup);
            
            // Update info panel with breath status
            updateBreathStatusInfo();
        }
        
        /**
         * Update breath status info in the panel
         */
        function updateBreathStatusInfo() {
            let balancedCount = 0;
            helixBreathRatios.forEach(data => {
                if (data.isBalanced) balancedCount++;
            });
            
            const infoEl = document.getElementById('infoBalanced');
            if (infoEl) {
                infoEl.textContent = `${balancedCount}/6`;
                infoEl.style.color = balancedCount >= 4 ? '#00ff66' : (balancedCount >= 2 ? '#ffff00' : '#ff6666');
            }
        }

        /**
         * Render a single DNA strand with breath-based lighting
         */
        function renderStrand(curveSegments, faceId, helixColor, isProjection, helixId, breathRatio) {
            // Get breath-adjusted properties
            const breathProps = getBreathAdjustedProperties(helixId, breathRatio);
            
            curveSegments.forEach(segment => {
                const tubeGeometry = new THREE.TubeGeometry(
                    segment.curve,
                    Math.floor(CONFIG.segments / 10),
                    CONFIG.tubeRadius * (segment.octaveId <= 7 ? 1 : 0.6),
                    8,
                    false
                );

                // Blend face color with helix color
                const faceColor = FACE_COLORS[faceId] || 0xffffff;
                let blendedColor = blendColors(faceColor, helixColor, 0.6);
                
                // Shift color toward warning if imbalanced
                blendedColor = shiftColorToWarning(blendedColor, breathProps.colorShift);

                // Apply breath-adjusted opacity
                const baseOpacity = getOctaveOpacity(segment.octaveId, segment.coherence, breathProps.opacityMultiplier);

                // Apply breath-adjusted emissive intensity
                const baseEmissive = getEmissiveIntensity(segment.octaveId, segment.coherence);
                const adjustedEmissive = baseEmissive * breathProps.opacityMultiplier;

                const material = new THREE.MeshPhongMaterial({
                    color: blendedColor,
                    emissive: blendedColor,
                    emissiveIntensity: adjustedEmissive,
                    transparent: true,
                    opacity: baseOpacity,
                    shininess: segment.octaveId <= 7 ? 120 : 40,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(tubeGeometry, material);
                mesh.userData = { 
                    faceId, 
                    octaveId: segment.octaveId,
                    isProjection,
                    coherence: segment.coherence,
                    helixId: helixId,
                    breathRatio: breathRatio,
                    pulseFrequency: breathProps.pulseFrequency,
                    pulseAmplitude: breathProps.pulseAmplitude,
                    baseOpacity: baseOpacity,
                    baseEmissive: adjustedEmissive
                };
                dnaGroup.add(mesh);
                
                // Add to breathing meshes for animation
                breathingMeshes.push(mesh);
            });
        }

        /**
         * Blend two colors
         */
        function blendColors(color1, color2, factor) {
            const r1 = (color1 >> 16) & 255;
            const g1 = (color1 >> 8) & 255;
            const b1 = color1 & 255;
            
            const r2 = (color2 >> 16) & 255;
            const g2 = (color2 >> 8) & 255;
            const b2 = color2 & 255;
            
            const r = Math.round(r1 * factor + r2 * (1 - factor));
            const g = Math.round(g1 * factor + g2 * (1 - factor));
            const b = Math.round(b1 * factor + b2 * (1 - factor));
            
            return (r << 16) | (g << 8) | b;
        }

        /**
         * Render DNA rungs (connections between strands)
         */
        function renderDNARungs() {
            if (rungsGroup) {
                scene.remove(rungsGroup);
            }

            if (!showRungs) return;

            rungsGroup = new THREE.Group();

            DNA_HELICES.forEach(helix => {
                const helixCenter = getHelixCenterPosition(helix.id);
                const strand1Data = allFacesData[helix.strand1.faceId - 1];
                const strand2Data = allFacesData[helix.strand2.faceId - 1];
                
                if (!strand1Data || !strand2Data) return;

                // Create rungs at each octave level (12 rungs per helix = 72 total)
                for (let octaveId = 1; octaveId <= CONFIG.maxOctaves; octaveId++) {
                    if (octaveId > 7 && !showGhostOctaves) continue;
                    
                    const fibRadius = getFibonacciRadius(octaveId);
                    const y = ((octaveId - 1) / 7) * CONFIG.helixHeight;
                    
                    // Create multiple rungs per octave for DNA effect
                    const rungsPerOctave = 6;
                    for (let r = 0; r < rungsPerOctave; r++) {
                        const rungT = r / rungsPerOctave;
                        const angle = 2 * Math.PI * CONFIG.helixTurns * ((octaveId - 1 + rungT) / 7);
                        const rungY = y + (rungT * CONFIG.helixHeight / 7);
                        
                        const spiralR = CONFIG.strandRadius * fibRadius;
                        
                        // Strand 1 position
                        const x1 = helixCenter.x + spiralR * Math.cos(angle);
                        const z1 = helixCenter.z + spiralR * Math.sin(angle);
                        
                        // Strand 2 position (180° offset)
                        const x2 = helixCenter.x + spiralR * Math.cos(angle + Math.PI);
                        const z2 = helixCenter.z + spiralR * Math.sin(angle + Math.PI);
                        
                        // Create rung
                        const points = [
                            new THREE.Vector3(x1, rungY, z1),
                            new THREE.Vector3(x2, rungY, z2)
                        ];
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const opacity = getOctaveOpacity(octaveId, 0.5);
                        const material = new THREE.LineBasicMaterial({
                            color: helix.color,
                            transparent: true,
                            opacity: opacity * 0.5, // Rungs are subtler than strands
                            linewidth: 1
                        });
                        
                        const rung = new THREE.Line(geometry, material);
                        rung.userData = { helixId: helix.id, octaveId, type: 'rung' };
                        rungsGroup.add(rung);
                    }
                }
            });

            scene.add(rungsGroup);
        }

        /**
         * Add octave markers
         */
        function addOctaveMarkers() {
            const octaves = [
                { id: 1, name: 'Survival', color: 0xff3333 },
                { id: 2, name: 'Structure', color: 0xff9900 },
                { id: 3, name: 'Relationships', color: 0xffff00 },
                { id: 4, name: 'Creativity', color: 0x00ff66 },
                { id: 5, name: 'Expression', color: 0x00ffcc },
                { id: 6, name: 'Vision', color: 0x00ccff },
                { id: 7, name: 'Radiance', color: 0xaa00ff },
                { id: 8, name: 'Transcendence', color: 0xff66ff },
                { id: 9, name: 'Unity', color: 0xccccff },
                { id: 10, name: 'Cosmic', color: 0x9999ff },
                { id: 11, name: 'Divine', color: 0x6666ff },
                { id: 12, name: '∞', color: 0x3333ff }
            ];

            octaves.forEach(octave => {
                const isFuture = octave.id > 7;
                if (isFuture && !showGhostOctaves) return;
                
                const y = ((octave.id - 1) / 7) * CONFIG.helixHeight;
                const opacity = isFuture ? 0.3 : 0.7;
                
                // Central marker
                const geometry = new THREE.SphereGeometry(isFuture ? 0.15 : 0.25, 12, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: octave.color,
                    transparent: true,
                    opacity: opacity
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(0, y, 0);
                dnaGroup.add(sphere);

                // Octave label
                if (showLabels) {
                    const labelText = `O${octave.id}: ${octave.name}`;
                    addLabel(labelText, 0, y - 0.5, 0, octave.color, opacity);
                }
            });
        }

        /**
         * Add text label
         */
        function addLabel(text, x, y, z, color, opacity = 1.0) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.globalAlpha = opacity;
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.font = 'bold 36px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 256, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: opacity
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(4, 1, 1);

            dnaGroup.add(sprite);
        }

        /**
         * Handle mouse click on DNA helices
         */
        function onCanvasClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            if (!dnaGroup) return;
            
            const intersects = raycaster.intersectObjects(dnaGroup.children, true);

            if (intersects.length > 0) {
                const firstHit = intersects[0];
                const userData = firstHit.object.userData;
                
                if (userData.faceId) {
                    // Find which helix this face belongs to
                    const helix = DNA_HELICES.find(h => 
                        h.strand1.faceId === userData.faceId || h.strand2.faceId === userData.faceId
                    );
                    
                    if (helix) {
                        selectHelix(helix);
                    }
                }
            } else {
                // Clicked on empty space - deselect
                deselectHelix();
            }
        }

        /**
         * Select and analyze a helix
         */
        async function selectHelix(helix) {
            selectedHelix = helix;
            
            // Highlight the selected helix
            highlightHelix(helix);
            
            // Show diagnostic panel
            await showDiagnosticPanel(helix);
        }

        /**
         * Deselect helix
         */
        function deselectHelix() {
            selectedHelix = null;
            document.getElementById('diagnosticPanel').style.display = 'none';
            
            // Remove highlights
            highlightedMeshes.forEach(mesh => {
                if (mesh.material.emissiveIntensity) {
                    mesh.material.emissiveIntensity /= 2; // Restore original
                }
            });
            highlightedMeshes = [];
        }

        /**
         * Highlight a helix visually
         */
        function highlightHelix(helix) {
            if (!dnaGroup) return;
            
            highlightedMeshes = [];
            
            dnaGroup.children.forEach(mesh => {
                if (mesh.userData.faceId === helix.strand1.faceId || 
                    mesh.userData.faceId === helix.strand2.faceId) {
                    // Brighten the selected helix
                    if (mesh.material.emissiveIntensity !== undefined) {
                        mesh.material.emissiveIntensity *= 2;
                        highlightedMeshes.push(mesh);
                    }
                }
            });
        }

        /**
         * Show diagnostic panel with breath axis analysis
         */
        async function showDiagnosticPanel(helix) {
            const panel = document.getElementById('diagnosticPanel');
            const title = document.getElementById('diagnosticTitle');
            const content = document.getElementById('diagnosticContent');
            
            title.textContent = `🌊 ${helix.name.toUpperCase()} AXIS`;
            
            // Load data
            const strand1Data = allFacesData[helix.strand1.faceId - 1];
            const strand2Data = allFacesData[helix.strand2.faceId - 1];
            
            if (!strand1Data || !strand2Data) {
                content.innerHTML = '<p>Data loading...</p>';
                panel.style.display = 'block';
                return;
            }
            
            // Fetch breath analysis
            const breathData = await fetchBreathAnalysis();
            const axisData = findAxisData(breathData, helix);
            
            // Generate content
            content.innerHTML = generateDiagnosticContent(helix, strand1Data, strand2Data, axisData);
            
            panel.style.display = 'block';
        }

        /**
         * Fetch breath analysis from API
         */
        async function fetchBreathAnalysis() {
            try {
                const response = await fetch(`${API_BASE}/breath-analysis`);
                const result = await response.json();
                return result.success ? result.data : null;
            } catch (error) {
                console.error('Failed to fetch breath analysis:', error);
                return null;
            }
        }

        /**
         * Find axis data from breath analysis
         */
        function findAxisData(breathData, helix) {
            if (!breathData || !breathData.axes) return null;
            
            // Match by face IDs
            return breathData.axes.find(axis => 
                (axis.projectionFace === helix.strand1.faceId && axis.receptionFace === helix.strand2.faceId) ||
                (axis.projectionFace === helix.strand2.faceId && axis.receptionFace === helix.strand1.faceId)
            );
        }

        /**
         * Generate diagnostic panel HTML content
         */
        function generateDiagnosticContent(helix, strand1Data, strand2Data, axisData) {
            // Calculate energies
            const face1 = allFacesData[helix.strand1.faceId - 1];
            const face2 = allFacesData[helix.strand2.faceId - 1];
            
            // Get face energies from the loaded data
            const energy1 = face1?.ballHelix?.coherenceData?.[0]?.value || 0.5;
            const energy2 = face2?.ballHelix?.coherenceData?.[0]?.value || 0.5;
            
            const breathRatio = energy2 > 0 ? energy1 / energy2 : 0;
            const isBalanced = breathRatio >= 0.8 && breathRatio <= 1.2;
            
            let html = `
                <div class="breath-ratio-display" style="border-color: ${isBalanced ? '#00ff66' : '#ff6666'}">
                    <div style="text-align: center; color: #888; font-size: 11px;">BREATH RATIO</div>
                    <div class="breath-ratio-value" style="color: ${isBalanced ? '#00ff66' : '#ff6666'}">
                        ${breathRatio.toFixed(2)}
                    </div>
                    <div class="breath-status ${isBalanced ? 'balanced' : 'imbalanced'}">
                        ${getBreathStatusText(breathRatio)}
                    </div>
                </div>

                <div class="strand-info">
                    <div class="strand-card" style="border-color: ${getStrandColor(helix, true)}">
                        <div class="strand-label">↗️ Projection (Exhale)</div>
                        <div class="strand-name" style="color: ${getStrandColor(helix, true)}">${helix.strand1.name}</div>
                        <div style="font-size: 11px; color: #aaa;">Face ${helix.strand1.faceId}</div>
                        <div class="energy-bar">
                            <div class="energy-fill" style="width: ${energy1 * 100}%; background: linear-gradient(90deg, ${getStrandColor(helix, true)}, ${getStrandColor(helix, true)}88);"></div>
                        </div>
                        <div style="margin-top: 6px; font-size: 11px; font-weight: bold; color: ${getStrandColor(helix, true)}">
                            Energy: ${(energy1 * 100).toFixed(1)}%
                        </div>
                    </div>

                    <div class="strand-card" style="border-color: ${getStrandColor(helix, false)}">
                        <div class="strand-label">↙️ Reception (Inhale)</div>
                        <div class="strand-name" style="color: ${getStrandColor(helix, false)}">${helix.strand2.name}</div>
                        <div style="font-size: 11px; color: #aaa;">Face ${helix.strand2.faceId}</div>
                        <div class="energy-bar">
                            <div class="energy-fill" style="width: ${energy2 * 100}%; background: linear-gradient(90deg, ${getStrandColor(helix, false)}, ${getStrandColor(helix, false)}88);"></div>
                        </div>
                        <div style="margin-top: 6px; font-size: 11px; font-weight: bold; color: ${getStrandColor(helix, false)}">
                            Energy: ${(energy2 * 100).toFixed(1)}%
                        </div>
                    </div>
                </div>

                <div class="tension-section">
                    <div class="section-title">🔍 ROOT TENSIONS</div>
                    ${generateTensionAnalysis(helix, strand1Data, strand2Data, breathRatio)}
                </div>

                <div class="tension-section">
                    <div class="section-title">💡 RECOMMENDED ACTIONS</div>
                    ${generateRecommendations(helix, breathRatio, energy1, energy2)}
                </div>
            `;
            
            return html;
        }

        /**
         * Get breath status text
         */
        function getBreathStatusText(ratio) {
            if (ratio >= 0.8 && ratio <= 1.2) return '✅ BALANCED - Healthy Flow';
            if (ratio > 1.2) return '⚠️ OVER-EXHALING - Too much projection, not enough reception';
            if (ratio < 0.8) return '⚠️ UNDER-EXHALING - Too much reception, not enough projection';
            return '⚠️ IMBALANCED';
        }

        /**
         * Get strand color
         */
        function getStrandColor(helix, isStrand1) {
            const faceId = isStrand1 ? helix.strand1.faceId : helix.strand2.faceId;
            const color = FACE_COLORS[faceId] || 0xffffff;
            return `#${color.toString(16).padStart(6, '0')}`;
        }

        /**
         * Generate tension analysis HTML
         */
        function generateTensionAnalysis(helix, strand1Data, strand2Data, breathRatio) {
            const imbalance = Math.abs(1 - breathRatio);
            
            if (imbalance < 0.2) {
                return `<div style="color: #00ff66; padding: 10px; background: rgba(0,255,102,0.1); border-radius: 6px;">
                    ✅ This axis is in excellent balance! Both strands are supporting each other harmoniously.
                </div>`;
            }
            
            let html = '';
            
            // Identify which side is overactive
            const overactive = breathRatio > 1 ? helix.strand1 : helix.strand2;
            const underactive = breathRatio > 1 ? helix.strand2 : helix.strand1;
            const gap = Math.abs(breathRatio - 1) * 100;
            
            html += `
                <div class="octave-tension" style="border-color: #ff6666;">
                    <div class="octave-header" style="color: #ff6666;">
                        ⚠️ Imbalance Detected: ${gap.toFixed(0)}% gap
                    </div>
                    <div class="kpi-detail">
                        <strong style="color: #ff9999;">Overactive (Exhaling too much):</strong><br>
                        → ${overactive.name} is at high energy<br>
                        → Risk: Burnout, over-extension, depletion
                    </div>
                    <div class="kpi-detail" style="margin-top: 8px;">
                        <strong style="color: #99ccff;">Underactive (Not inhaling enough):</strong><br>
                        → ${underactive.name} is depleted<br>
                        → Risk: Foundation weakness, lack of capacity
                    </div>
                </div>
            `;
            
            return html;
        }

        /**
         * Generate recommendations HTML
         */
        function generateRecommendations(helix, breathRatio, energy1, energy2) {
            if (Math.abs(1 - breathRatio) < 0.2) {
                return `<div class="action-item">
                    <span class="action-number">✓</span>
                    <strong>Maintain current balance</strong> - This axis is healthy. Continue current practices.
                </div>`;
            }
            
            let html = '';
            let actionNum = 1;
            
            if (breathRatio > 1.2) {
                // Over-exhaling (strand1 too high)
                html += `
                    <div class="action-item">
                        <span class="action-number">${actionNum++}</span>
                        <strong>Reduce ${helix.strand1.name} intensity</strong> - Scale back by ${((breathRatio - 1) * 20).toFixed(0)}%
                    </div>
                    <div class="action-item">
                        <span class="action-number">${actionNum++}</span>
                        <strong>Strengthen ${helix.strand2.name} foundation</strong> - Focus on building capacity and resources
                    </div>
                    <div class="action-item">
                        <span class="action-number">${actionNum++}</span>
                        <strong>Target Ratio: 0.8-1.2</strong> - Aim for balanced breath flow
                    </div>
                `;
            } else if (breathRatio < 0.8) {
                // Under-exhaling (strand2 too high)
                html += `
                    <div class="action-item">
                        <span class="action-number">${actionNum++}</span>
                        <strong>Increase ${helix.strand1.name} activity</strong> - Boost projection/action by ${((1 - breathRatio) * 20).toFixed(0)}%
                    </div>
                    <div class="action-item">
                        <span class="action-number">${actionNum++}</span>
                        <strong>Convert ${helix.strand2.name} capacity into action</strong> - You have resources, now use them!
                    </div>
                    <div class="action-item">
                        <span class="action-number">${actionNum++}</span>
                        <strong>Target Ratio: 0.8-1.2</strong> - Aim for balanced breath flow
                    </div>
                `;
            }
            
            return html;
        }

        // Event listeners
        document.getElementById('resetCameraBtn').addEventListener('click', () => {
            camera.position.set(30, 25, 30);
            controls.target.set(0, 10, 0);
            controls.update();
        });

        document.getElementById('pausePlayBtn').addEventListener('click', (e) => {
            animationRunning = !animationRunning;
            controls.autoRotate = animationRunning;
            e.target.textContent = animationRunning ? 'Pause' : 'Play';
            e.target.classList.toggle('active');
        });

        document.getElementById('toggleLabelsBtn').addEventListener('click', (e) => {
            showLabels = !showLabels;
            renderDNAHelices();
            renderDNARungs();
            e.target.textContent = showLabels ? 'Hide Labels' : 'Show Labels';
        });

        document.getElementById('toggleRungsBtn').addEventListener('click', (e) => {
            showRungs = !showRungs;
            renderDNARungs();
            e.target.textContent = showRungs ? 'Hide DNA Rungs' : 'Show DNA Rungs';
        });

        document.getElementById('toggleGhostBtn').addEventListener('click', (e) => {
            showGhostOctaves = !showGhostOctaves;
            renderDNAHelices();
            renderDNARungs();
            e.target.textContent = showGhostOctaves ? 'Hide Future Octaves' : 'Show Future Octaves';
        });

        document.getElementById('closeDiagnostic').addEventListener('click', () => {
            deselectHelix();
        });

        /**
         * Handle mouse move for hover effects
         */
        function onCanvasMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            if (!dnaGroup) return;
            
            const intersects = raycaster.intersectObjects(dnaGroup.children, true);
            
            if (intersects.length > 0 && intersects[0].object.userData.faceId) {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // Mouse event handlers
        canvas.addEventListener('click', onCanvasClick, false);
        canvas.addEventListener('mousemove', onCanvasMove, false);

        // Animation loop
        let lastTime = Date.now();
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (animationRunning) {
                controls.update();
                
                // Breathing animation - UPDATE BREATH TIME
                breathTime += 0.016; // ~60fps
                
                // Animate all breathing meshes
                breathingMeshes.forEach(mesh => {
                    if (!mesh.userData.pulseFrequency) return;
                    
                    const freq = mesh.userData.pulseFrequency;
                    const amp = mesh.userData.pulseAmplitude;
                    const baseOpacity = mesh.userData.baseOpacity;
                    const baseEmissive = mesh.userData.baseEmissive;
                    
                    // Sine wave for breathing pulse
                    const breathPhase = Math.sin(breathTime * freq);
                    
                    // Modulate opacity (inhale = brighter, exhale = dimmer)
                    const opacityModulation = 1 + (breathPhase * amp);
                    mesh.material.opacity = baseOpacity * opacityModulation;
                    
                    // Modulate emissive intensity (synchronized with opacity)
                    const emissiveModulation = 1 + (breathPhase * amp * 0.5);
                    mesh.material.emissiveIntensity = baseEmissive * emissiveModulation;
                });
            }

            renderer.render(scene, camera);

            // Update FPS
            frameCount++;
            const now = Date.now();
            if (now - lastTime >= 1000) {
                document.getElementById('infoFPS').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        async function init() {
            try {
                await loadAllFaces();
                renderDNAHelices();
                renderDNARungs();
                document.getElementById('loading').style.display = 'none';
                animate();
                console.log('🧬 Organizational DNA Visualization Complete!');
                console.log('📊 6 Double Helices | 12 Strands | 72 DNA Rungs | φ = 1.618...');
            } catch (error) {
                console.error('Failed to initialize:', error);
                document.getElementById('loading').innerHTML = '<div class="spinner"></div><div>Error loading DNA data. Check console.</div>';
            }
        }

        init();
    </script>
</body>
</html>

